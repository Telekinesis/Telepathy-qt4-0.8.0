<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Tp::Client::ChannelInterface Class Reference</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td width="1">&nbsp;&nbsp;</td>
<td class="postheader" valign="center">
<a href="index.html">
<font color="#004faf">Home</font></a>&nbsp;&middot;
<a href="classes.html">
<font color="#004faf">All Classes</font></a>&nbsp;&middot;
<a href="namespaces.html">
<font color="#004faf">All Namespaces</font></a>&nbsp;&middot;
<a href="modules.html">
<font color="#004faf">Modules</font></a>&nbsp;&middot;
<a href="functions.html">
<font color="#004faf">Functions</font></a>&nbsp;&middot;
<a href="files.html">
<font color="#004faf">Files</font></a>
</td>
</tr>
</table>
<!-- Generated by Doxygen 1.7.5 -->
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="a00655.html">Tp</a>      </li>
      <li class="navelem"><a class="el" href="a00659.html">Client</a>      </li>
      <li class="navelem"><a class="el" href="a00088.html">ChannelInterface</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-slots">Public Slots</a> &#124;
<a href="#signals">Signals</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">Tp::Client::ChannelInterface Class Reference<div class="ingroups"><a class="el" href="a00667.html">Channel proxies</a></div></div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Tp::Client::ChannelInterface" --><!-- doxytag: inherits="Tp::AbstractInterface" -->
<p><code>#include &lt;<a class="el" href="a00461_source.html">TelepathyQt4/Channel</a>&gt;</code></p>

<p>Inherits <a class="el" href="a00033.html">Tp::AbstractInterface</a>.</p>

<p><a href="a00919.html">List of all members.</a></p>
<h2><a name="pub-slots"></a>
Public Slots</h2>
<ul>
<li><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbuspendingreply.html">QDBusPendingReply</a> <a class="el" href="a00088.html#a822439bf7adb2ce890cf8066ea01a1ff">Close</a> (int <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusabstractinterface.html#timeout">timeout</a>=-1)
<li><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbuspendingreply.html">QDBusPendingReply</a>&lt; <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &gt; <a class="el" href="a00088.html#aa14a76049f40ba119845f2c52f84bdeb">GetChannelType</a> (int <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusabstractinterface.html#timeout">timeout</a>=-1)
<li><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbuspendingreply.html">QDBusPendingReply</a>&lt; uint, uint &gt; <a class="el" href="a00088.html#a135d5199c69e92039f81bcbad48d6e27">GetHandle</a> (int <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusabstractinterface.html#timeout">timeout</a>=-1)
<li><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbuspendingreply.html">QDBusPendingReply</a>&lt; <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> &gt; <a class="el" href="a00088.html#a65855cac589751eee7717e266caa7c6c">GetInterfaces</a> (int <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusabstractinterface.html#timeout">timeout</a>=-1)
</ul>
<h2><a name="signals"></a>
Signals</h2>
<ul>
<li>void <a class="el" href="a00088.html#a42005b6ea5c4fb962a2a8789a35741da">Closed</a> ()
</ul>
<h2><a name="pub-methods"></a>
Public Member Functions</h2>
<ul>
<li><a class="el" href="a00088.html#a892880ace6b153f8c4cb6bd19066c074">ChannelInterface</a> (const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;busName, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;objectPath, <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qobject.html">QObject</a> *<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qobject.html#parent">parent</a>=0)
<li><a class="el" href="a00088.html#a9044ef5ba0d6848c83511ab1d53d9c56">ChannelInterface</a> (const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusconnection.html">QDBusConnection</a> &amp;<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusabstractinterface.html#connection">connection</a>, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;busName, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;objectPath, <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qobject.html">QObject</a> *<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qobject.html#parent">parent</a>=0)
<li><a class="el" href="a00088.html#a248dd4161960529ca31f7cca130cbe36">ChannelInterface</a> (<a class="el" href="a00195.html">Tp::DBusProxy</a> *proxy)
<li><a class="el" href="a00309.html">Tp::PendingVariant</a> * <a class="el" href="a00088.html#a48df5dad17fa70262c8d59b2c75c83c2">requestPropertyChannelType</a> () const 
<li><a class="el" href="a00309.html">Tp::PendingVariant</a> * <a class="el" href="a00088.html#ac0ef159d0249fe8fe9faf1b6a5dbba99">requestPropertyInterfaces</a> () const 
<li><a class="el" href="a00309.html">Tp::PendingVariant</a> * <a class="el" href="a00088.html#aba93f0a84612cc6c2adf866eaff3e763">requestPropertyTargetHandle</a> () const 
<li><a class="el" href="a00309.html">Tp::PendingVariant</a> * <a class="el" href="a00088.html#aa04a1d3032316883c6ce5085f20caf68">requestPropertyTargetID</a> () const 
<li><a class="el" href="a00309.html">Tp::PendingVariant</a> * <a class="el" href="a00088.html#a389f3d423b4da14c328fd0ddbe20b8ae">requestPropertyTargetHandleType</a> () const 
<li><a class="el" href="a00309.html">Tp::PendingVariant</a> * <a class="el" href="a00088.html#a32516a093708b2b8accc930b8252dcfa">requestPropertyRequested</a> () const 
<li><a class="el" href="a00309.html">Tp::PendingVariant</a> * <a class="el" href="a00088.html#a88f912db7a4d0680d3d78d928369cbe7">requestPropertyInitiatorHandle</a> () const 
<li><a class="el" href="a00309.html">Tp::PendingVariant</a> * <a class="el" href="a00088.html#af7de86e324a198e115d6957f3da83fa1">requestPropertyInitiatorID</a> () const 
<li><a class="el" href="a00310.html">Tp::PendingVariantMap</a> * <a class="el" href="a00088.html#afedf34d3aac0c21bd9f6c49cc2709472">requestAllProperties</a> () const 
</ul>
<h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2>
<ul>
<li>static <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qlatin1string.html">QLatin1String</a> <a class="el" href="a00088.html#ae7005466f857a3b9117b4c191e3ef65e">staticInterfaceName</a> ()
</ul>
<h2><a name="pro-methods"></a>
Protected Member Functions</h2>
<ul>
<li>virtual void <a class="el" href="a00088.html#a0a29ac5a212f2e0b0e9db5544d245ee1">invalidate</a> (<a class="el" href="a00195.html">Tp::DBusProxy</a> *, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;)
</ul>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Channel." </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a892880ace6b153f8c4cb6bd19066c074"></a><!-- doxytag: member="Tp::Client::ChannelInterface::ChannelInterface" ref="a892880ace6b153f8c4cb6bd19066c074" args="(const QString &amp;busName, const QString &amp;objectPath, QObject *parent=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tp::Client::ChannelInterface::ChannelInterface </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>busName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>objectPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qobject.html">QObject</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a <a class="el" href="a00088.html">ChannelInterface</a> associated with the given object on the session bus.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">busName</td><td>Name of the service the object is on. </td></tr>
    <tr><td class="paramname">objectPath</td><td>Path to the object on the service. </td></tr>
    <tr><td class="paramname">parent</td><td>Passed to the parent class constructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9044ef5ba0d6848c83511ab1d53d9c56"></a><!-- doxytag: member="Tp::Client::ChannelInterface::ChannelInterface" ref="a9044ef5ba0d6848c83511ab1d53d9c56" args="(const QDBusConnection &amp;connection, const QString &amp;busName, const QString &amp;objectPath, QObject *parent=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tp::Client::ChannelInterface::ChannelInterface </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusconnection.html">QDBusConnection</a> &amp;&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>busName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>objectPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qobject.html">QObject</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a <a class="el" href="a00088.html">ChannelInterface</a> associated with the given object on the given bus.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">connection</td><td>The bus via which the object can be reached. </td></tr>
    <tr><td class="paramname">busName</td><td>Name of the service the object is on. </td></tr>
    <tr><td class="paramname">objectPath</td><td>Path to the object on the service. </td></tr>
    <tr><td class="paramname">parent</td><td>Passed to the parent class constructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a248dd4161960529ca31f7cca130cbe36"></a><!-- doxytag: member="Tp::Client::ChannelInterface::ChannelInterface" ref="a248dd4161960529ca31f7cca130cbe36" args="(Tp::DBusProxy *proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tp::Client::ChannelInterface::ChannelInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00195.html">Tp::DBusProxy</a> *&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a <a class="el" href="a00088.html">ChannelInterface</a> associated with the same object as the given proxy.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The proxy to use. It will also be the <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qobject.html#parent">QObject::parent()</a> for this object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae7005466f857a3b9117b4c191e3ef65e"></a><!-- doxytag: member="Tp::Client::ChannelInterface::staticInterfaceName" ref="ae7005466f857a3b9117b4c191e3ef65e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qlatin1string.html">QLatin1String</a> Tp::Client::ChannelInterface::staticInterfaceName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the name of the interface "org.freedesktop.Telepathy.Channel", which this class represents.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The D-Bus interface name. </dd></dl>

</div>
</div>
<a class="anchor" id="a48df5dad17fa70262c8d59b2c75c83c2"></a><!-- doxytag: member="Tp::Client::ChannelInterface::requestPropertyChannelType" ref="a48df5dad17fa70262c8d59b2c75c83c2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00309.html">Tp::PendingVariant</a>* Tp::Client::ChannelInterface::requestPropertyChannelType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property <code>ChannelType</code> of type <code><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a></code>.</p>
 
 <p>The channel's type. This cannot change once the channel has
   been created.</p>
 
 <p>For compatibility between older connection managers and newer
   clients, if this is unavailable or is an empty string,
   clients MUST use the result of calling
     <a class="el" href="a00088.html#aa14a76049f40ba119845f2c52f84bdeb">GetChannelType()</a>  .</p>
 
 <div class="rationale">
   The GetAll method lets clients retrieve all properties in one
   round-trip, which is desirable.
 </div>
 
 <p>When requesting a channel, the request MUST specify a channel
   type, and the request MUST fail if the specified channel type
   cannot be supplied.</p>
 
 <div class="rationale">
   Common sense.
 </div>
 <dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="ac0ef159d0249fe8fe9faf1b6a5dbba99"></a><!-- doxytag: member="Tp::Client::ChannelInterface::requestPropertyInterfaces" ref="ac0ef159d0249fe8fe9faf1b6a5dbba99" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00309.html">Tp::PendingVariant</a>* Tp::Client::ChannelInterface::requestPropertyInterfaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property <code>Interfaces</code> of type <code><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a></code>.</p>
 
 <p>Extra interfaces provided by this channel. This SHOULD NOT include
   the channel type and the Channel interface itself, and cannot
   change once the channel has been created.</p>
 
 <p>For compatibility between older connection managers and newer
   clients, if this is unavailable, or if this is an empty list and
     <a class="el" href="a00088.html#a48df5dad17fa70262c8d59b2c75c83c2">ChannelType </a>  is an empty string,
   clients MUST use the result of calling
     <a class="el" href="a00088.html#a65855cac589751eee7717e266caa7c6c">GetInterfaces()</a>  instead. If this is an
   empty list but ChannelType is non-empty, clients SHOULD NOT call
   GetInterfaces; this implies that connection managers that implement
   the ChannelType property MUST also implement the Interfaces property
   correctly.</p>
 
 <div class="rationale">
   The GetAll method lets clients retrieve all properties in one
   round-trip, which is desirable.
 </div>
 
 <p>When requesting a channel with a particular value for this
   property, the request must fail without side-effects unless the
   connection manager expects to be able to provide a channel whose
   interfaces include at least the interfaces requested.</p>
 <dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="aba93f0a84612cc6c2adf866eaff3e763"></a><!-- doxytag: member="Tp::Client::ChannelInterface::requestPropertyTargetHandle" ref="aba93f0a84612cc6c2adf866eaff3e763" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00309.html">Tp::PendingVariant</a>* Tp::Client::ChannelInterface::requestPropertyTargetHandle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property <code>TargetHandle</code> of type <code>uint</code>.</p>
 
 <p>The handle (a representation for the identifier) of the contact,
   chatroom, etc. with which this handle communicates. Its type
   is given by the   <a class="el" href="a00088.html#a389f3d423b4da14c328fd0ddbe20b8ae">TargetHandleType </a>  
   property.</p>
 
 <p>This is fixed for the lifetime of the channel, so channels which
   could potentially be used to communicate with multiple contacts,
   and do not have an identity of their own (such as a Handle_Type_Room
   handle), must have TargetHandleType set to Handle_Type_None and
   TargetHandle set to 0.</p>
 
 <p>Unlike in the telepathy-spec 0.16 API, there is no particular
   uniqueness guarantee - there can be many channels with the same
   (channel type, handle type, handle) tuple. This is necessary
   to support conversation threads in XMPP and SIP, for example.</p>
 
 <p>If this is present in a channel request, it must be nonzero,
     <a class="el" href="a00088.html#a389f3d423b4da14c328fd0ddbe20b8ae">TargetHandleType </a>  
   MUST be present and not Handle_Type_None, and
     <a class="el" href="a00088.html#aa04a1d3032316883c6ce5085f20caf68">TargetID </a>  MUST NOT be
   present. Properties from
     org.freedesktop.Telepathy.Channel.Interface.Addressing.DRAFT  
   MUST NOT be present.</p>
 
 <p>The channel that satisfies the request MUST either:</p>
 
 <ul>
   <li>have the specified TargetHandle property; or</li>
   <li>have   <a class="el" href="a00088.html#a389f3d423b4da14c328fd0ddbe20b8ae">TargetHandleType </a>  =
     Handle_Type_None, TargetHandle = 0, and be configured such that
     it could communicate with the specified handle in some other way
     (e.g. have the requested contact handle in its Group
     interface)</li>
 </ul>
 <dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="aa04a1d3032316883c6ce5085f20caf68"></a><!-- doxytag: member="Tp::Client::ChannelInterface::requestPropertyTargetID" ref="aa04a1d3032316883c6ce5085f20caf68" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00309.html">Tp::PendingVariant</a>* Tp::Client::ChannelInterface::requestPropertyTargetID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property <code>TargetID</code> of type <code><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a></code>.</p>
 
 <p>The string that would result from inspecting the
     <a class="el" href="a00088.html#aba93f0a84612cc6c2adf866eaff3e763">TargetHandle </a>  
   property (i.e. the identifier in the IM protocol of the contact,
   room, etc. with which this channel communicates), or the empty
   string if the TargetHandle is 0.</p>
 
 <div class="rationale">
   <p>The presence of this property avoids the following race
     condition:</p>
 
   <ul>
     <li>New channel C is signalled with target handle T</li>
     <li>Client calls   <a class="el" href="a00130.html#a7327cef43f7cfd1fe915727689d10edd">ConnectionInterface::InspectHandles()</a>  (CONTACT,
       [T])</li>
     <li>Channel C closes, removing the last reference to handle T</li>
     <li>  <a class="el" href="a00130.html#a7327cef43f7cfd1fe915727689d10edd">ConnectionInterface::InspectHandles()</a>  (CONTACT,
       [T]) returns an error</li>
   </ul>
 </div>
 
 <p>If this is present in a channel request,
     <a class="el" href="a00088.html#a389f3d423b4da14c328fd0ddbe20b8ae">TargetHandleType </a>  
   MUST be present and not Handle_Type_None, and
     <a class="el" href="a00088.html#aba93f0a84612cc6c2adf866eaff3e763">TargetHandle </a>  MUST NOT be
   present. Properties from
     org.freedesktop.Telepathy.Channel.Interface.Addressing.DRAFT  
   MUST NOT be present.The request MUST fail with error InvalidHandle,
   without side-effects, if the requested TargetID would not be
   accepted by
     <a class="el" href="a00130.html#a9358410e2c3e263d29dd071cb1c03ec3">ConnectionInterface::RequestHandles()</a>  .</p>
 
 <p>The returned channel must be related to the handle corresponding
   to the given identifier, in the same way as if TargetHandle
   had been part of the request instead.</p>
 
 <div class="rationale">
   <p>Requesting channels with a string identifier saves a round-trip
     (the call to RequestHandles). It also allows the channel
     dispatcher to accept a channel request for an account that is not
     yet connected (and thus has no valid handles), bring the account
     online, and pass on the same parameters to the new connection's
     CreateChannel method.</p>
 </div>
 <dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="a389f3d423b4da14c328fd0ddbe20b8ae"></a><!-- doxytag: member="Tp::Client::ChannelInterface::requestPropertyTargetHandleType" ref="a389f3d423b4da14c328fd0ddbe20b8ae" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00309.html">Tp::PendingVariant</a>* Tp::Client::ChannelInterface::requestPropertyTargetHandleType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property <code>TargetHandleType</code> of type <code>uint</code>.</p>
 
 <p>The type of   <a class="el" href="a00088.html#aba93f0a84612cc6c2adf866eaff3e763">TargetHandle </a>  .</p>
 
 <p>If this is omitted from a channel request, connection managers
   SHOULD treat this as equivalent to Handle_Type_None.</p>
 
 <p>If this is omitted or is Handle_Type_None,
     <a class="el" href="a00088.html#aba93f0a84612cc6c2adf866eaff3e763">TargetHandle </a>  and
     <a class="el" href="a00088.html#aa04a1d3032316883c6ce5085f20caf68">TargetID </a>  MUST be omitted from the
   request.</p>
 <dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="a32516a093708b2b8accc930b8252dcfa"></a><!-- doxytag: member="Tp::Client::ChannelInterface::requestPropertyRequested" ref="a32516a093708b2b8accc930b8252dcfa" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00309.html">Tp::PendingVariant</a>* Tp::Client::ChannelInterface::requestPropertyRequested </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property <code>Requested</code> of type <code>bool</code>.</p>
 
 <p>True if this channel was created in response to a local request,
   such as a call to
     <a class="el" href="a00130.html#aa47cba559bbbe54b170bec5f3e044801">ConnectionInterface::RequestChannel()</a>  
   or
     <a class="el" href="a00148.html#a1c7158c9b48d622551be4ae53f555497">ConnectionInterfaceRequestsInterface::CreateChannel()</a>  .</p>
 
 <div class="rationale">
   <p>The idea of this property is to distinguish between &quot;incoming&quot;
     and &quot;outgoing&quot; channels, in a way that doesn't break down when
     considering special cases like contact lists that are automatically
     created on connection to the server, or chatrooms that an
     IRC proxy/bouncer like irssi-proxy or bip was already in.</p>
 
   <p>The reason we want to make that distinction is that UIs for
     things that the user explicitly requested should start up
     automatically, whereas for incoming messages and VoIP calls we
     should first ask the user whether they want to open the messaging
     UI or accept the call.</p>
 </div>
 
 <p>If the channel was not explicitly requested (even if it was
   created as a side-effect of a call to one of those functions,
   e.g. because joining a Tube in a MUC context on XMPP implies
   joining that MUC), then this property is false.</p>
 
 <p>For compatibility with older connection managers, clients SHOULD
   assume that this property is true if they see a channel announced
   by the
     <a class="el" href="a00130.html#abe677e48098e91a45b7179ccd177a482">ConnectionInterface::NewChannel()</a>  
   signal with the suppress_handler parameter set to true.</p>
 
 <div class="rationale">
   <p>In a correct connection manager, the only way to get such a
     channel is to request it.</p>
 </div>
 
 <p>Clients MAY additionally assume that this property is false
   if they see a channel announced by the NewChannel signal with the
   suppress_handler parameter set to false.</p>
 
 <div class="rationale">
   <p>This is more controversial, since it's possible to get that
     parameter set to false by requesting a channel. However, there's
     no good reason to do so, and we've deprecated this practice.</p>
 
   <p>In the particular case of the channel dispatcher, the only
     side-effect of wrongly thinking a channel is unrequested
     is likely to be that the user has to confirm that they want to
     use it, so it seems fairly harmless to assume in the channel
     dispatcher that channels with suppress_handler false are
     indeed unrequested.</p>
 </div>
 
 <p>It does not make sense for this property to be in channel
   requests—it will always be true for channels returned by
   CreateChannel, and callers of EnsureChannel cannot control whether an
   existing channel was originally requested locally—so it MUST NOT
   be accepted.</p>
 <dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="a88f912db7a4d0680d3d78d928369cbe7"></a><!-- doxytag: member="Tp::Client::ChannelInterface::requestPropertyInitiatorHandle" ref="a88f912db7a4d0680d3d78d928369cbe7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00309.html">Tp::PendingVariant</a>* Tp::Client::ChannelInterface::requestPropertyInitiatorHandle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property <code>InitiatorHandle</code> of type <code>uint</code>.</p>
 
 <p>The contact who initiated the channel; for instance, the contact
   who invited the local user to a chatroom, or the contact who
   initiated a call.</p>
 
 <p>This does <em>not</em> necessarily represent the contact who
   created the underlying protocol-level construct. For instance, if
   Rob creates a chatroom, Will joins that chatroom, and Will invites Simon
   to join it, then Simon will see Will as the InitiatorHandle of the
   channel representing the chatroom.</p>
 
 <div class="rationale">
   <p>The room creator is generally a less useful piece of information
     than the inviter, is less likely to be available at invitation
     time (i.e. can't necessarily be an immutable property), and is
     less likely to be available at all. The creator of a chatroom
     is not currently available via Telepathy; if added in future, it
     is likely to be made available as a property on the Chatroom
     interface (<a href="http://bugs.freedesktop.org/show_bug.cgi?id=23151">bug 23151</a>).</p>
 </div>
 
 <p>For channels requested by the
   local user, this MUST be the value of
     <a class="el" href="a00130.html#a2e9535cf988e586fb1b8afc0c86c10ec">ConnectionInterface::SelfHandle </a>  
   at the time the channel was created (i.e. not a channel-specific
   handle).</p>
 
 <div class="rationale">
   <p>On some protocols, the SelfHandle may change (as signalled by
       <a class="el" href="a00130.html#a8fbec1b80a6b878296c888fafab52b1e">ConnectionInterface::SelfHandleChanged()</a>  ),
     but this property is immutable. Hence, locally-requested channels'
     InitiatorHandle and InitiatorID may not match the current
     SelfHandle;   <a class="el" href="a00088.html#a32516a093708b2b8accc930b8252dcfa">Requested </a>  can be used to
     determine whether the channel was created locally.</p>
 </div>
 
 <p>For channels requested by a remote user, this MUST be their handle.
   If unavailable or not applicable, this MUST be 0 (for instance,
   contact lists are not really initiated by anyone in particular, and
   it's easy to imagine a protocol where chatroom invitations can be
   anonymous).</p>
 
 <p>For channels with the   <a class="el" href="a00095.html">ChannelInterfaceGroupInterface</a>  
   interface, this SHOULD be the same
   contact who is signalled as the &quot;Actor&quot; causing the self-handle
   to be placed in the local-pending set.</p>
 
 <p>This SHOULD NOT be a channel-specific handle, if possible.</p>
 
 <p>It does not make sense for this property to be in channel
   requests - the initiator will always be the local user - so it
   MUST NOT be accepted.</p>
 <dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="af7de86e324a198e115d6957f3da83fa1"></a><!-- doxytag: member="Tp::Client::ChannelInterface::requestPropertyInitiatorID" ref="af7de86e324a198e115d6957f3da83fa1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00309.html">Tp::PendingVariant</a>* Tp::Client::ChannelInterface::requestPropertyInitiatorID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property <code>InitiatorID</code> of type <code><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a></code>.</p>
 
 <p>The string that would result from inspecting the
     <a class="el" href="a00088.html#a88f912db7a4d0680d3d78d928369cbe7">InitiatorHandle </a>  
   property (i.e. the initiator's identifier in the IM protocol).</p>
 
 <div class="rationale">
   <p>The presence of this property avoids the following race
     condition:</p>
 
   <ul>
     <li>New StreamedMedia channel C is signalled with initiator
       handle I</li>
     <li>Client calls   <a class="el" href="a00130.html#a7327cef43f7cfd1fe915727689d10edd">ConnectionInterface::InspectHandles()</a>  (CONTACT,
       [I])</li>
     <li>Channel C closes, removing the last reference to handle I</li>
     <li>  <a class="el" href="a00130.html#a7327cef43f7cfd1fe915727689d10edd">ConnectionInterface::InspectHandles()</a>  (CONTACT,
       [I]) returns an error</li>
     <li>Client can indicate that a call was missed, but not who
       called!</li>
   </ul>
 </div>
 
 <p>It does not make sense for this property to be in channel
   requests - the initiator will always be the local user - so it
   MUST NOT be accepted.</p>
 <dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="afedf34d3aac0c21bd9f6c49cc2709472"></a><!-- doxytag: member="Tp::Client::ChannelInterface::requestAllProperties" ref="afedf34d3aac0c21bd9f6c49cc2709472" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00310.html">Tp::PendingVariantMap</a>* Tp::Client::ChannelInterface::requestAllProperties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Request all of the <a class="el" href="a00660.html">DBus</a> properties on the interface.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant map which will emit finished when the properties have been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="a822439bf7adb2ce890cf8066ea01a1ff"></a><!-- doxytag: member="Tp::Client::ChannelInterface::Close" ref="a822439bf7adb2ce890cf8066ea01a1ff" args="(int timeout=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbuspendingreply.html">QDBusPendingReply</a> Tp::Client::ChannelInterface::Close </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>-1</code></td><td>)</td>
          <td><code> [inline, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Begins a call to the D-Bus method <code>Close</code> on the remote object.</p>
<p>Request that the channel be closed. This is not the case until the Closed signal has been emitted, and depending on the connection manager this may simply remove you from the channel on the server, rather than causing it to stop existing entirely. Some channels such as contact list channels may not be closed.</p>
<p>Note that <em>timeout</em> is ignored as of now. It will be used once <a href="http://bugreports.qt.nokia.com/browse/QTBUG-11775">http://bugreports.qt.nokia.com/browse/QTBUG-11775</a> is fixed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>The timeout in milliseconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa14a76049f40ba119845f2c52f84bdeb"></a><!-- doxytag: member="Tp::Client::ChannelInterface::GetChannelType" ref="aa14a76049f40ba119845f2c52f84bdeb" args="(int timeout=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbuspendingreply.html">QDBusPendingReply</a>&lt;<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a>&gt; Tp::Client::ChannelInterface::GetChannelType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>-1</code></td><td>)</td>
          <td><code> [inline, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Begins a call to the D-Bus method <code>GetChannelType</code> on the remote object.</p>
<p>Returns the interface name for the type of this channel. Clients SHOULD use the ChannelType property instead, falling back to this method only if necessary. The GetAll method lets clients retrieve all properties in one round-trip.</p>
<p>Note that <em>timeout</em> is ignored as of now. It will be used once <a href="http://bugreports.qt.nokia.com/browse/QTBUG-11775">http://bugreports.qt.nokia.com/browse/QTBUG-11775</a> is fixed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>The timeout in milliseconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<p>The interface name </p>

</div>
</div>
<a class="anchor" id="a135d5199c69e92039f81bcbad48d6e27"></a><!-- doxytag: member="Tp::Client::ChannelInterface::GetHandle" ref="a135d5199c69e92039f81bcbad48d6e27" args="(int timeout=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbuspendingreply.html">QDBusPendingReply</a>&lt;uint, uint&gt; Tp::Client::ChannelInterface::GetHandle </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>-1</code></td><td>)</td>
          <td><code> [inline, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Begins a call to the D-Bus method <code>GetHandle</code> on the remote object.</p>
<p>Returns the handle type and number if this channel represents a communication with a particular contact, room or server-stored list, or zero if it is transient and defined only by its contents. Clients SHOULD use the TargetHandle and TargetHandleType properties instead, falling back to this method only if necessary. The GetAll method lets clients retrieve all properties in one round-trip.</p>
<p>Note that <em>timeout</em> is ignored as of now. It will be used once <a href="http://bugreports.qt.nokia.com/browse/QTBUG-11775">http://bugreports.qt.nokia.com/browse/QTBUG-11775</a> is fixed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>The timeout in milliseconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<p>The same as TargetHandleType.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<p>The same as TargetHandle. </p>

</div>
</div>
<a class="anchor" id="a65855cac589751eee7717e266caa7c6c"></a><!-- doxytag: member="Tp::Client::ChannelInterface::GetInterfaces" ref="a65855cac589751eee7717e266caa7c6c" args="(int timeout=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbuspendingreply.html">QDBusPendingReply</a>&lt;<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a>&gt; Tp::Client::ChannelInterface::GetInterfaces </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>-1</code></td><td>)</td>
          <td><code> [inline, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Begins a call to the D-Bus method <code>GetInterfaces</code> on the remote object.</p>
<p>Get the optional interfaces implemented by the channel. Clients SHOULD use the Interfaces property instead, falling back to this method only if necessary. The GetAll method lets clients retrieve all properties in one round-trip.</p>
<p>Note that <em>timeout</em> is ignored as of now. It will be used once <a href="http://bugreports.qt.nokia.com/browse/QTBUG-11775">http://bugreports.qt.nokia.com/browse/QTBUG-11775</a> is fixed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>The timeout in milliseconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<p>An array of the D-Bus interface names </p>

</div>
</div>
<a class="anchor" id="a42005b6ea5c4fb962a2a8789a35741da"></a><!-- doxytag: member="Tp::Client::ChannelInterface::Closed" ref="a42005b6ea5c4fb962a2a8789a35741da" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tp::Client::ChannelInterface::Closed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Represents the signal <code>Closed</code> on the remote object.</p>
<p>Emitted when the channel has been closed. Method calls on the channel are no longer valid after this signal has been emitted, and the connection manager may then remove the object from the bus at any point. </p>

</div>
</div>
<a class="anchor" id="a0a29ac5a212f2e0b0e9db5544d245ee1"></a><!-- doxytag: member="Tp::Client::ChannelInterface::invalidate" ref="a0a29ac5a212f2e0b0e9db5544d245ee1" args="(Tp::DBusProxy *, const QString &amp;, const QString &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tp::Client::ChannelInterface::invalidate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00195.html">Tp::DBusProxy</a> *&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="a00033.html#a79dde56ba44455f47c7c354ada07467a">Tp::AbstractInterface</a>.</p>

</div>
</div>
</div>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td width="30%">Copyright &copy; 2008-2011 Collabora Ltd. and Nokia Corporation</td>
<td width="30%" align="right"><div align="right">Telepathy-Qt4 0.8.0</div></td>
</tr></table></div></address>
</body>
</html>
