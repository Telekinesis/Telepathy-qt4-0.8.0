<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Tp::ChannelDispatchOperation Class Reference</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td width="1">&nbsp;&nbsp;</td>
<td class="postheader" valign="center">
<a href="index.html">
<font color="#004faf">Home</font></a>&nbsp;&middot;
<a href="classes.html">
<font color="#004faf">All Classes</font></a>&nbsp;&middot;
<a href="namespaces.html">
<font color="#004faf">All Namespaces</font></a>&nbsp;&middot;
<a href="modules.html">
<font color="#004faf">Modules</font></a>&nbsp;&middot;
<a href="functions.html">
<font color="#004faf">Functions</font></a>&nbsp;&middot;
<a href="files.html">
<font color="#004faf">Files</font></a>
</td>
</tr>
</table>
<!-- Generated by Doxygen 1.7.5 -->
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="a00655.html">Tp</a>      </li>
      <li class="navelem"><a class="el" href="a00084.html">ChannelDispatchOperation</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#signals">Signals</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">Tp::ChannelDispatchOperation Class Reference<div class="ingroups"><a class="el" href="a00669.html">ChannelDispatchOperation proxies</a></div></div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Tp::ChannelDispatchOperation" --><!-- doxytag: inherits="Tp::StatefulDBusProxy,OptionalInterfaceFactory&lt; ChannelDispatchOperation &gt;" -->
<p>The <a class="el" href="a00084.html" title="The ChannelDispatchOperation class represents a Telepathy channel dispatch operation.">ChannelDispatchOperation</a> class represents a Telepathy channel dispatch operation.  
 <a href="a00084.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00439_source.html">TelepathyQt4/ChannelDispatchOperation</a>&gt;</code></p>

<p>Inherits <a class="el" href="a00376.html">Tp::StatefulDBusProxy</a>, and <a class="el" href="a00279.html">Tp::OptionalInterfaceFactory&lt; ChannelDispatchOperation &gt;</a>.</p>

<p><a href="a00724.html">List of all members.</a></p>
<h2><a name="signals"></a>
Signals</h2>
<ul>
<li>void <a class="el" href="a00084.html#adbec0d5c90cd39e41aea005a57d4face">channelLost</a> (const Tp::ChannelPtr &amp;channel, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;errorName, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;errorMessage)
</ul>
<h2><a name="pub-methods"></a>
Public Member Functions</h2>
<ul>
<li>virtual <a class="el" href="a00084.html#ad65a5030d2e07cda4e94f56335540897">~ChannelDispatchOperation</a> ()
<li>ConnectionPtr <a class="el" href="a00084.html#a97a31d8837c887c5c3cfb3b384b9daf8">connection</a> () const 
<li>AccountPtr <a class="el" href="a00084.html#a522666f095aecf88e940caa3c5c760aa">account</a> () const 
<li><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qlist.html">QList</a>&lt; ChannelPtr &gt; <a class="el" href="a00084.html#a6dfcf1643ae5add061cfc85cbfcc75f9">channels</a> () const 
<li><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> <a class="el" href="a00084.html#a7d2fddbd2bdb7d340777d881d8c21042">possibleHandlers</a> () const 
<li><a class="el" href="a00301.html">PendingOperation</a> * <a class="el" href="a00084.html#a6110ece4fc4e28a5a8fc071fb1871f9d">handleWith</a> (const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;handler)
<li><a class="el" href="a00301.html">PendingOperation</a> * <a class="el" href="a00084.html#abe3cc768fce132036939f63384fe7c82">claim</a> ()
<li><a class="el" href="a00301.html">PendingOperation</a> * <a class="el" href="a00084.html#af0bd9c46a0e88aa49c72984a43300b33">claim</a> (const AbstractClientHandlerPtr &amp;handler)
</ul>
<h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2>
<ul>
<li>static ChannelDispatchOperationPtr <a class="el" href="a00084.html#af2641c395dc9df9431c21d7175e71bbe">create</a> (const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusconnection.html">QDBusConnection</a> &amp;bus, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;objectPath, const QVariantMap &amp;immutableProperties, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qlist.html">QList</a>&lt; ChannelPtr &gt; &amp;initialChannels, const AccountFactoryConstPtr &amp;accountFactory, const ConnectionFactoryConstPtr &amp;connectionFactory, const ChannelFactoryConstPtr &amp;channelFactory, const ContactFactoryConstPtr &amp;contactFactory)
</ul>
<h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2>
<ul>
<li>static const <a class="el" href="a00205.html">Feature</a> <a class="el" href="a00084.html#a0d296de60678b7e1b60b679028f35e7f">FeatureCore</a>
</ul>
<h2><a name="pro-methods"></a>
Protected Member Functions</h2>
<ul>
<li><a class="el" href="a00084.html#acecbbde978de90f3683ca5396807896b">ChannelDispatchOperation</a> (const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusconnection.html">QDBusConnection</a> &amp;bus, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;objectPath, const QVariantMap &amp;immutableProperties, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qlist.html">QList</a>&lt; ChannelPtr &gt; &amp;initialChannels, const AccountFactoryConstPtr &amp;accountFactory, const ConnectionFactoryConstPtr &amp;connectionFactory, const ChannelFactoryConstPtr &amp;channelFactory, const ContactFactoryConstPtr &amp;contactFactory)
<li><a class="el" href="a00085.html">Client::ChannelDispatchOperationInterface</a> * <a class="el" href="a00084.html#ab64648baf1e2797cdb63cb7884f95ae4">baseInterface</a> () const 
</ul>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="a00084.html" title="The ChannelDispatchOperation class represents a Telepathy channel dispatch operation.">ChannelDispatchOperation</a> class represents a Telepathy channel dispatch operation. </p>
<p>One of the channel dispatcher's functions is to offer incoming channels to Approver clients for approval. An approver should generally ask the user whether they want to participate in the requested communication channels (join the chat or chatroom, answer the call, accept the file transfer, or whatever is appropriate). A collection of channels offered in this way is represented by a <a class="el" href="a00084.html" title="The ChannelDispatchOperation class represents a Telepathy channel dispatch operation.">ChannelDispatchOperation</a> object.</p>
<p>If the user wishes to accept the communication channels, the approver should call <a class="el" href="a00084.html#a6110ece4fc4e28a5a8fc071fb1871f9d">handleWith()</a> to indicate the user's or approver's preferred handler for the channels (the empty string indicates no particular preference, and will cause any suitable handler to be used).</p>
<p>If the user wishes to reject the communication channels, or if the user accepts the channels and the approver will handle them itself, the approver should call <a class="el" href="a00084.html#abe3cc768fce132036939f63384fe7c82">claim()</a>. If the resulting <a class="el" href="a00301.html" title="The PendingOperation class is a base class for pending asynchronous operations.">PendingOperation</a> succeeds, the approver immediately has control over the channels as their primary handler, and may do anything with them (in particular, it may close them in whatever way seems most appropriate).</p>
<p>There are various situations in which the channel dispatch operation will be closed, causing the <a class="el" href="a00195.html#a2ec4e99262674ba916321d11398c6b58">DBusProxy::invalidated()</a> signal to be emitted. If this happens, the approver should stop prompting the user.</p>
<p>Because all approvers are launched simultaneously, the user might respond to another approver; if this happens, the invalidated signal will be emitted with the error code <a class="el" href="a00683.html#ga9f3296b721194780d7fa5505fe03faa8">TP_QT4_ERROR_OBJECT_REMOVED</a>.</p>
<p>If a channel closes, the signal <a class="el" href="a00084.html#adbec0d5c90cd39e41aea005a57d4face">channelLost()</a> is emitted. If all channels close, there is nothing more to dispatch, so the invalidated signal will be emitted with the error code <a class="el" href="a00683.html#ga9f3296b721194780d7fa5505fe03faa8">TP_QT4_ERROR_OBJECT_REMOVED</a>.</p>
<p>If the channel dispatcher crashes or exits, the invalidated signal will be emitted with the error code <a class="el" href="a00683.html#ga21cff18362f596f68a4cae453793ffc5">TP_QT4_DBUS_ERROR_NAME_HAS_NO_OWNER</a>. In a high-quality implementation, the dispatcher should be restarted, at which point it will create new channel dispatch operations for any undispatched channels, and the approver will be notified again. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad65a5030d2e07cda4e94f56335540897"></a><!-- doxytag: member="Tp::ChannelDispatchOperation::~ChannelDispatchOperation" ref="ad65a5030d2e07cda4e94f56335540897" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tp::ChannelDispatchOperation::~ChannelDispatchOperation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Class destructor. </p>

</div>
</div>
<a class="anchor" id="acecbbde978de90f3683ca5396807896b"></a><!-- doxytag: member="Tp::ChannelDispatchOperation::ChannelDispatchOperation" ref="acecbbde978de90f3683ca5396807896b" args="(const QDBusConnection &amp;bus, const QString &amp;objectPath, const QVariantMap &amp;immutableProperties, const QList&lt; ChannelPtr &gt; &amp;initialChannels, const AccountFactoryConstPtr &amp;accountFactory, const ConnectionFactoryConstPtr &amp;connectionFactory, const ChannelFactoryConstPtr &amp;channelFactory, const ContactFactoryConstPtr &amp;contactFactory)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tp::ChannelDispatchOperation::ChannelDispatchOperation </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusconnection.html">QDBusConnection</a> &amp;&#160;</td>
          <td class="paramname"><em>bus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>objectPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVariantMap &amp;&#160;</td>
          <td class="paramname"><em>immutableProperties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qlist.html">QList</a>&lt; ChannelPtr &gt; &amp;&#160;</td>
          <td class="paramname"><em>initialChannels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AccountFactoryConstPtr &amp;&#160;</td>
          <td class="paramname"><em>accountFactory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConnectionFactoryConstPtr &amp;&#160;</td>
          <td class="paramname"><em>connectionFactory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ChannelFactoryConstPtr &amp;&#160;</td>
          <td class="paramname"><em>channelFactory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContactFactoryConstPtr &amp;&#160;</td>
          <td class="paramname"><em>contactFactory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a new channel dispatch operation object using the given <em>bus</em>, the given factories and the given initial channels.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bus</td><td><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusconnection.html">QDBusConnection</a> to use </td></tr>
    <tr><td class="paramname">objectPath</td><td>The channel dispatch operation object path. </td></tr>
    <tr><td class="paramname">immutableProperties</td><td>The channel dispatch operation immutable properties. </td></tr>
    <tr><td class="paramname">initialChannels</td><td>The channels this CDO has initially (further tracking is done internally). </td></tr>
    <tr><td class="paramname">accountFactory</td><td>The account factory to use. </td></tr>
    <tr><td class="paramname">connectionFactory</td><td>The connection factory to use. </td></tr>
    <tr><td class="paramname">channelFactory</td><td>The channel factory to use. </td></tr>
    <tr><td class="paramname">contactFactory</td><td>The contact factory to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="af2641c395dc9df9431c21d7175e71bbe"></a><!-- doxytag: member="Tp::ChannelDispatchOperation::create" ref="af2641c395dc9df9431c21d7175e71bbe" args="(const QDBusConnection &amp;bus, const QString &amp;objectPath, const QVariantMap &amp;immutableProperties, const QList&lt; ChannelPtr &gt; &amp;initialChannels, const AccountFactoryConstPtr &amp;accountFactory, const ConnectionFactoryConstPtr &amp;connectionFactory, const ChannelFactoryConstPtr &amp;channelFactory, const ContactFactoryConstPtr &amp;contactFactory)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChannelDispatchOperationPtr Tp::ChannelDispatchOperation::create </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusconnection.html">QDBusConnection</a> &amp;&#160;</td>
          <td class="paramname"><em>bus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>objectPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVariantMap &amp;&#160;</td>
          <td class="paramname"><em>immutableProperties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qlist.html">QList</a>&lt; ChannelPtr &gt; &amp;&#160;</td>
          <td class="paramname"><em>initialChannels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AccountFactoryConstPtr &amp;&#160;</td>
          <td class="paramname"><em>accountFactory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConnectionFactoryConstPtr &amp;&#160;</td>
          <td class="paramname"><em>connectionFactory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ChannelFactoryConstPtr &amp;&#160;</td>
          <td class="paramname"><em>channelFactory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContactFactoryConstPtr &amp;&#160;</td>
          <td class="paramname"><em>contactFactory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a new channel dispatch operation object using the given <em>bus</em>, the given factories and the given initial channels.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bus</td><td><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusconnection.html">QDBusConnection</a> to use. </td></tr>
    <tr><td class="paramname">objectPath</td><td>The channel dispatch operation object path. </td></tr>
    <tr><td class="paramname">immutableProperties</td><td>The channel dispatch operation immutable properties. </td></tr>
    <tr><td class="paramname">initialChannels</td><td>The channels this CDO has initially (further tracking is done internally). </td></tr>
    <tr><td class="paramname">accountFactory</td><td>The account factory to use. </td></tr>
    <tr><td class="paramname">connectionFactory</td><td>The connection factory to use. </td></tr>
    <tr><td class="paramname">channelFactory</td><td>The channel factory to use. </td></tr>
    <tr><td class="paramname">contactFactory</td><td>The contact factory to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A ChannelDispatchOperationPtr object pointing to the newly created <a class="el" href="a00084.html" title="The ChannelDispatchOperation class represents a Telepathy channel dispatch operation.">ChannelDispatchOperation</a> object. </dd></dl>

</div>
</div>
<a class="anchor" id="a97a31d8837c887c5c3cfb3b384b9daf8"></a><!-- doxytag: member="Tp::ChannelDispatchOperation::connection" ref="a97a31d8837c887c5c3cfb3b384b9daf8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConnectionPtr Tp::ChannelDispatchOperation::connection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the connection with which the channels for this dispatch operation are associated.</p>
<p>This method requires <a class="el" href="a00084.html#a0d296de60678b7e1b60b679028f35e7f">ChannelDispatchOperation::FeatureCore</a> to be ready.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the <a class="el" href="a00127.html" title="The Connection class represents a Telepathy connection.">Connection</a> object. </dd></dl>

</div>
</div>
<a class="anchor" id="a522666f095aecf88e940caa3c5c760aa"></a><!-- doxytag: member="Tp::ChannelDispatchOperation::account" ref="a522666f095aecf88e940caa3c5c760aa" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AccountPtr Tp::ChannelDispatchOperation::account </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the account with which the connection and channels for this dispatch operation are associated.</p>
<p>This method requires <a class="el" href="a00084.html#a0d296de60678b7e1b60b679028f35e7f">ChannelDispatchOperation::FeatureCore</a> to be ready.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the <a class="el" href="a00035.html" title="The Account class represents a Telepathy account.">Account</a> object. </dd></dl>

</div>
</div>
<a class="anchor" id="a6dfcf1643ae5add061cfc85cbfcc75f9"></a><!-- doxytag: member="Tp::ChannelDispatchOperation::channels" ref="a6dfcf1643ae5add061cfc85cbfcc75f9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qlist.html">QList</a>&lt; ChannelPtr &gt; Tp::ChannelDispatchOperation::channels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the channels to be dispatched.</p>
<p>This method requires <a class="el" href="a00084.html#a0d296de60678b7e1b60b679028f35e7f">ChannelDispatchOperation::FeatureCore</a> to be ready.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A list of pointers to <a class="el" href="a00077.html" title="The Channel class represents a Telepathy channel.">Channel</a> objects. </dd></dl>

</div>
</div>
<a class="anchor" id="a7d2fddbd2bdb7d340777d881d8c21042"></a><!-- doxytag: member="Tp::ChannelDispatchOperation::possibleHandlers" ref="a7d2fddbd2bdb7d340777d881d8c21042" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> Tp::ChannelDispatchOperation::possibleHandlers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the well known bus names (starting with org.freedesktop.Telepathy.Client.) of the possible Handlers for this dispatch operation channels with the preferred handlers first.</p>
<p>As a result, approvers should use the first handler by default, unless they have a reason to do otherwise.</p>
<p>This method requires <a class="el" href="a00084.html#a0d296de60678b7e1b60b679028f35e7f">ChannelDispatchOperation::FeatureCore</a> to be ready.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>List of possible handlers names. </dd></dl>

</div>
</div>
<a class="anchor" id="a6110ece4fc4e28a5a8fc071fb1871f9d"></a><!-- doxytag: member="Tp::ChannelDispatchOperation::handleWith" ref="a6110ece4fc4e28a5a8fc071fb1871f9d" args="(const QString &amp;handler)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00301.html">PendingOperation</a> * Tp::ChannelDispatchOperation::handleWith </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called by an approver to accept a channel bundle and request that the given handler be used to handle it.</p>
<p>If successful, this method will cause the <a class="el" href="a00084.html" title="The ChannelDispatchOperation class represents a Telepathy channel dispatch operation.">ChannelDispatchOperation</a> object to disappear, emitting invalidated with error <a class="el" href="a00683.html#ga9f3296b721194780d7fa5505fe03faa8">TP_QT4_ERROR_OBJECT_REMOVED</a>.</p>
<p>However, this method may fail because the dispatch has already been completed and the object has already gone. If this occurs, it indicates that another approver has asked for the bundle to be handled by a particular handler. The approver must not attempt to interact with the channels further in this case, unless it is separately invoked as the handler.</p>
<p>Approvers which are also channel handlers should use <a class="el" href="a00084.html#abe3cc768fce132036939f63384fe7c82">claim()</a> instead of this method to request that they can handle a channel bundle themselves.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>The well-known bus name (starting with org.freedesktop.Telepathy.Client.) of the channel handler that should handle the channel, or an empty string if the client has no preferred channel handler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="a00301.html" title="The PendingOperation class is a base class for pending asynchronous operations.">PendingOperation</a> which will emit <a class="el" href="a00301.html#addbb8c4462019ffdf19095a31da0cc7a">PendingOperation::finished</a> when the call has finished. </dd></dl>

</div>
</div>
<a class="anchor" id="abe3cc768fce132036939f63384fe7c82"></a><!-- doxytag: member="Tp::ChannelDispatchOperation::claim" ref="abe3cc768fce132036939f63384fe7c82" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00301.html">PendingOperation</a> * Tp::ChannelDispatchOperation::claim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called by an approver to claim channels for closing them.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="a00301.html" title="The PendingOperation class is a base class for pending asynchronous operations.">PendingOperation</a> which will emit <a class="el" href="a00301.html#addbb8c4462019ffdf19095a31da0cc7a">PendingOperation::finished</a> when the call has finished. </dd></dl>

</div>
</div>
<a class="anchor" id="af0bd9c46a0e88aa49c72984a43300b33"></a><!-- doxytag: member="Tp::ChannelDispatchOperation::claim" ref="af0bd9c46a0e88aa49c72984a43300b33" args="(const AbstractClientHandlerPtr &amp;handler)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00301.html">PendingOperation</a> * Tp::ChannelDispatchOperation::claim </td>
          <td>(</td>
          <td class="paramtype">const AbstractClientHandlerPtr &amp;&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called by an approver to claim channels for handling internally. If this method is called successfully, the <em>handler</em> becomes the handler for the channel, but does not have the <a class="el" href="a00031.html#abc44780bc349b383e6be81582de1866c">AbstractClientHandler::handleChannels()</a> method called on it.</p>
<p>Approvers wishing to reject channels must call this method to claim ownership of them, and must not call requestClose() on the channels unless/until this method returns successfully.</p>
<p>The channel dispatcher can't know how best to close arbitrary channel types, so it leaves it up to the approver to do so. For instance, for text channels it is necessary to acknowledge any messages that have already been displayed to the user first - ideally, the approver would display and then acknowledge the messages - or to call <a class="el" href="a00077.html#acb1a800352ab8cec80aa2035fe803e15">Channel::requestClose()</a> if the destructive behaviour of that method is desired.</p>
<p>Similarly, an approver for streamed media channels can close the channel with a reason (e.g. "busy") if desired. The channel dispatcher, which is designed to have no specific knowledge of particular channel types, can't do that.</p>
<p>If successful, this method will cause the <a class="el" href="a00084.html" title="The ChannelDispatchOperation class represents a Telepathy channel dispatch operation.">ChannelDispatchOperation</a> object to disappear, emitting Finished, in the same way as for <a class="el" href="a00084.html#a6110ece4fc4e28a5a8fc071fb1871f9d">handleWith()</a>.</p>
<p>This method may fail because the dispatch operation has already been completed. Again, see <a class="el" href="a00084.html#a6110ece4fc4e28a5a8fc071fb1871f9d">handleWith()</a> for more details. The approver must not attempt to interact with the channels further in this case.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>The channel handler, that should remain registered during the lifetime of <a class="el" href="a00084.html#a6dfcf1643ae5add061cfc85cbfcc75f9">channels()</a>, otherwise dispatching will fail if the channel dispatcher restarts. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="a00301.html" title="The PendingOperation class is a base class for pending asynchronous operations.">PendingOperation</a> which will emit <a class="el" href="a00301.html#addbb8c4462019ffdf19095a31da0cc7a">PendingOperation::finished</a> when the call has finished. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00084.html#abe3cc768fce132036939f63384fe7c82">claim()</a>, <a class="el" href="a00084.html#a6110ece4fc4e28a5a8fc071fb1871f9d">handleWith()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="adbec0d5c90cd39e41aea005a57d4face"></a><!-- doxytag: member="Tp::ChannelDispatchOperation::channelLost" ref="adbec0d5c90cd39e41aea005a57d4face" args="(const Tp::ChannelPtr &amp;channel, const QString &amp;errorName, const QString &amp;errorMessage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tp::ChannelDispatchOperation::channelLost </td>
          <td>(</td>
          <td class="paramtype">const Tp::ChannelPtr &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>errorName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>errorMessage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Emitted when a channel has closed before it could be claimed or handled. If this is emitted for the last remaining channel in a channel dispatch operation, it will immediately be followed by <a class="el" href="a00195.html#a2ec4e99262674ba916321d11398c6b58">invalidated()</a> with error <a class="el" href="a00683.html#ga9f3296b721194780d7fa5505fe03faa8">TP_QT4_ERROR_OBJECT_REMOVED</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The channel that was closed. </td></tr>
    <tr><td class="paramname">error</td><td>The name of a D-Bus error indicating why the channel closed. </td></tr>
    <tr><td class="paramname">errorMessage</td><td>The error message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab64648baf1e2797cdb63cb7884f95ae4"></a><!-- doxytag: member="Tp::ChannelDispatchOperation::baseInterface" ref="ab64648baf1e2797cdb63cb7884f95ae4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00085.html">Client::ChannelDispatchOperationInterface</a> * Tp::ChannelDispatchOperation::baseInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the ChannelDispatchOperationInterface for this <a class="el" href="a00084.html" title="The ChannelDispatchOperation class represents a Telepathy channel dispatch operation.">ChannelDispatchOperation</a> class. This method is protected since the convenience methods provided by this class should always be used instead of the interface by users of the class.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the existing <a class="el" href="a00085.html">Client::ChannelDispatchOperationInterface</a> object for this <a class="el" href="a00084.html" title="The ChannelDispatchOperation class represents a Telepathy channel dispatch operation.">ChannelDispatchOperation</a> object. </dd></dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a0d296de60678b7e1b60b679028f35e7f"></a><!-- doxytag: member="Tp::ChannelDispatchOperation::FeatureCore" ref="a0d296de60678b7e1b60b679028f35e7f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00205.html">Feature</a> <a class="el" href="a00084.html#a0d296de60678b7e1b60b679028f35e7f">Tp::ChannelDispatchOperation::FeatureCore</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="a00205.html" title="The Feature class represents a feature that can be enabled on demand.">Feature</a> representing the core that needs to become ready to make the <a class="el" href="a00084.html" title="The ChannelDispatchOperation class represents a Telepathy channel dispatch operation.">ChannelDispatchOperation</a> object usable.</p>
<p>Note that this feature must be enabled in order to use most <a class="el" href="a00084.html" title="The ChannelDispatchOperation class represents a Telepathy channel dispatch operation.">ChannelDispatchOperation</a> methods.</p>
<p>When calling <a class="el" href="a00334.html#a344fc63eaef5278cbf938eaa1ed4c635">isReady()</a>, <a class="el" href="a00334.html#ac02393f99a46725a4ffee32caaec13cc">becomeReady()</a>, this feature is implicitly added to the requested features. </p>

</div>
</div>
</div>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td width="30%">Copyright &copy; 2008-2011 Collabora Ltd. and Nokia Corporation</td>
<td width="30%" align="right"><div align="right">Telepathy-Qt4 0.8.0</div></td>
</tr></table></div></address>
</body>
</html>
