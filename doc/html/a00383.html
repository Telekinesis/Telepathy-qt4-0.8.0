<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Tp::StreamTubeClient Class Reference</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td width="1">&nbsp;&nbsp;</td>
<td class="postheader" valign="center">
<a href="index.html">
<font color="#004faf">Home</font></a>&nbsp;&middot;
<a href="classes.html">
<font color="#004faf">All Classes</font></a>&nbsp;&middot;
<a href="namespaces.html">
<font color="#004faf">All Namespaces</font></a>&nbsp;&middot;
<a href="modules.html">
<font color="#004faf">Modules</font></a>&nbsp;&middot;
<a href="functions.html">
<font color="#004faf">Functions</font></a>&nbsp;&middot;
<a href="files.html">
<font color="#004faf">Files</font></a>
</td>
</tr>
</table>
<!-- Generated by Doxygen 1.7.5 -->
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="a00655.html">Tp</a>      </li>
      <li class="navelem"><a class="el" href="a00383.html">StreamTubeClient</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#signals">Signals</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">Tp::StreamTubeClient Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Tp::StreamTubeClient" --><!-- doxytag: inherits="QObject,Tp::RefCounted" -->
<p>The <a class="el" href="a00383.html" title="The StreamTubeClient class is a Handler implementation for incoming Stream Tube channels, allowing an application to easily get notified about services they can connect to offered to them over Telepathy Tubes without worrying about the channel dispatching details.">StreamTubeClient</a> class is a Handler implementation for incoming Stream Tube channels, allowing an application to easily get notified about services they can connect to offered to them over Telepathy Tubes without worrying about the channel dispatching details.  
 <a href="a00383.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00634_source.html">TelepathyQt4/StreamTubeClient</a>&gt;</code></p>

<p>Inherits <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qobject.html">QObject</a>, and <a class="el" href="a00336.html">Tp::RefCounted</a>.</p>

<p><a href="a00819.html">List of all members.</a></p>
<h2><a name="nested-classes"></a>
Classes</h2>
<ul>
<li>class <a class="el" href="a00390.html">TcpSourceAddressGenerator</a>
<dl class="el"><dd class="mdescRight">The <a class="el" href="a00390.html" title="The StreamTubeClient::TcpSourceAddressGenerator abstract interface allows using socket source address...">StreamTubeClient::TcpSourceAddressGenerator</a> abstract interface allows using socket source address/port based access control for connecting to tubes accepted as TCP sockets.  <a href="a00390.html#details">More...</a><br/></dl><li>class <a class="el" href="a00393.html">Tube</a>
<dl class="el"><dd class="mdescRight">The <a class="el" href="a00393.html" title="The StreamTubeClient::Tube class represents a tube being handled by the client.">StreamTubeClient::Tube</a> class represents a tube being handled by the client.  <a href="a00393.html#details">More...</a><br/></dl></ul>
<h2><a name="signals"></a>
Signals</h2>
<ul>
<li>void <a class="el" href="a00383.html#ad4d666b7d56b22c951af65021f2d9e7e">tubeOffered</a> (const Tp::AccountPtr &amp;account, const Tp::IncomingStreamTubeChannelPtr &amp;tube)
<li>void <a class="el" href="a00383.html#ab8b5d535d458e1d0204fe1612b5280b2">tubeClosed</a> (const Tp::AccountPtr &amp;account, const Tp::IncomingStreamTubeChannelPtr &amp;tube, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;error, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;message)
<li>void <a class="el" href="a00383.html#a12d4647c8ad29a941ac6123905736f92">tubeAcceptedAsTcp</a> (const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qhostaddress.html">QHostAddress</a> &amp;listenAddress, quint16 listenPort, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qhostaddress.html">QHostAddress</a> &amp;sourceAddress, quint16 sourcePort, const Tp::AccountPtr &amp;account, const Tp::IncomingStreamTubeChannelPtr &amp;tube)
<li>void <a class="el" href="a00383.html#ad08bfa94a24811712e5c5ff2a1ac75bb">tubeAcceptedAsUnix</a> (const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;listenAddress, bool requiresCredentials, uchar credentialByte, const Tp::AccountPtr &amp;account, const Tp::IncomingStreamTubeChannelPtr &amp;tube)
<li>void <a class="el" href="a00383.html#a546354350619ba4a6e3868ad66f8059f">newConnection</a> (const Tp::AccountPtr &amp;account, const Tp::IncomingStreamTubeChannelPtr &amp;tube, uint connectionId)
<li>void <a class="el" href="a00383.html#aeaea793406ca40e9938afdd4d8c0d016">connectionClosed</a> (const Tp::AccountPtr &amp;account, const Tp::IncomingStreamTubeChannelPtr &amp;tube, uint connectionId, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;error, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;message)
</ul>
<h2><a name="pub-methods"></a>
Public Member Functions</h2>
<ul>
<li>virtual <a class="el" href="a00383.html#ac3a062f064bf9be0b8167de413034a4c">~StreamTubeClient</a> ()
<li>ClientRegistrarPtr <a class="el" href="a00383.html#a92732661ae0a10e7f2b21b67fc4da810">registrar</a> () const 
<li><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> <a class="el" href="a00383.html#a09436a56bb9da91a0b8c32a476ca63be">clientName</a> () const 
<li>bool <a class="el" href="a00383.html#ac662264d218ab334f69cdd2eb62afca7">isRegistered</a> () const 
<li>bool <a class="el" href="a00383.html#a4b9fd27d1b52389492906a6054f92e9b">monitorsConnections</a> () const 
<li>bool <a class="el" href="a00383.html#a0dd9d210fd985adc19c5cf214e065244">acceptsAsTcp</a> () const 
<li><a class="el" href="a00390.html">TcpSourceAddressGenerator</a> * <a class="el" href="a00383.html#a11aba03e2672913e71e405daea4b17da">tcpGenerator</a> () const 
<li>bool <a class="el" href="a00383.html#a78e666ade88e771e6b1a539258622575">acceptsAsUnix</a> () const 
<li>void <a class="el" href="a00383.html#abc9f3c4980b7e2b9013720b1aedde2b2">setToAcceptAsTcp</a> (<a class="el" href="a00390.html">TcpSourceAddressGenerator</a> *generator=0)
<li>void <a class="el" href="a00383.html#a829e13f23dffbbb50e5af68b35b9c18f">setToAcceptAsUnix</a> (bool requireCredentials=false)
<li><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qlist.html">QList</a>&lt; <a class="el" href="a00393.html">Tube</a> &gt; <a class="el" href="a00383.html#a4a72d17586682c78d2cb3df358a64748">tubes</a> () const 
<li><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qhash.html">QHash</a>&lt; <a class="el" href="a00393.html">Tube</a>, <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qset.html">QSet</a>&lt; uint &gt; &gt; <a class="el" href="a00383.html#a31d77a10ca40f3eb09ad506cb9c5f392">connections</a> () const 
</ul>
<h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2>
<ul>
<li>static StreamTubeClientPtr <a class="el" href="a00383.html#a46f483a430ddb98052253b28e160977b">create</a> (const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> &amp;p2pServices, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> &amp;roomServices=<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a>(), const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;clientName=<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a>(), bool monitorConnections=false, bool bypassApproval=false, const AccountFactoryConstPtr &amp;accountFactory=AccountFactory::create(<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusconnection.html#sessionBus">QDBusConnection::sessionBus</a>()), const ConnectionFactoryConstPtr &amp;connectionFactory=ConnectionFactory::create(<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusconnection.html#sessionBus">QDBusConnection::sessionBus</a>()), const ChannelFactoryConstPtr &amp;channelFactory=ChannelFactory::create(<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusconnection.html#sessionBus">QDBusConnection::sessionBus</a>()), const ContactFactoryConstPtr &amp;contactFactory=ContactFactory::create())
<li>static StreamTubeClientPtr <a class="el" href="a00383.html#af0c745c20a295b4f2fe78ba99fbbabc4">create</a> (const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusconnection.html">QDBusConnection</a> &amp;bus, const AccountFactoryConstPtr &amp;accountFactory, const ConnectionFactoryConstPtr &amp;connectionFactory, const ChannelFactoryConstPtr &amp;channelFactory, const ContactFactoryConstPtr &amp;contactFactory, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> &amp;p2pServices, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> &amp;roomServices=<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a>(), const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;clientName=<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a>(), bool monitorConnections=false, bool bypassApproval=false)
<li>static StreamTubeClientPtr <a class="el" href="a00383.html#a0f43076d2684766b22326b8f165deb02">create</a> (const AccountManagerPtr &amp;accountManager, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> &amp;p2pServices, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> &amp;roomServices=<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a>(), const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;clientName=<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a>(), bool monitorConnections=false, bool bypassApproval=false)
<li>static StreamTubeClientPtr <a class="el" href="a00383.html#a118bf57c77e658ee93e05b0ee31b3578">create</a> (const ClientRegistrarPtr &amp;registrar, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> &amp;p2pServices, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> &amp;roomServices=<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a>(), const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;clientName=<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a>(), bool monitorConnections=false, bool bypassApproval=false)
</ul>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="a00383.html" title="The StreamTubeClient class is a Handler implementation for incoming Stream Tube channels, allowing an application to easily get notified about services they can connect to offered to them over Telepathy Tubes without worrying about the channel dispatching details.">StreamTubeClient</a> class is a Handler implementation for incoming Stream Tube channels, allowing an application to easily get notified about services they can connect to offered to them over Telepathy Tubes without worrying about the channel dispatching details. </p>
<p>Telepathy Tubes is a technology for connecting arbitrary applications together through the IM network (and sometimes with direct peer-to-peer connections), such that issues like firewall/NAT traversal are automatically handled. Stream Tubes in particular offer properties similar to SOCK_STREAM sockets. The <a class="el" href="a00383.html" title="The StreamTubeClient class is a Handler implementation for incoming Stream Tube channels, allowing an application to easily get notified about services they can connect to offered to them over Telepathy Tubes without worrying about the channel dispatching details.">StreamTubeClient</a> class negotiates tubes offered to us so that an application can connect such bytestream sockets of theirs to them. The <a class="el" href="a00384.html" title="The StreamTubeServer class is a Handler implementation for outgoing Stream Tube channels, allowing an application to easily export a TCP network server over Telepathy Tubes without worrying about the channel dispatching details.">StreamTubeServer</a> class is the counterpart, offering services from a bytestream socket server to tubes requested to be initiated.</p>
<p>Both peer-to-peer (<code>TargetHandleType</code> == <a class="el" href="a00655.html#ga36fa367f622d8b98416393b3fe4c89d2a5c0c85266c24696c080d2a688ec8bfa3">HandleTypeContact</a>) and group (<code>TargetHandleType</code> == <a class="el" href="a00655.html#ga36fa367f622d8b98416393b3fe4c89d2ac4186e266a163cb4ced697e949b02cd3">HandleTypeRoom</a>) channels are supported, and it's possible to specify the tube services to handle for each separately. There must be at least one service in total declared, as it never makes sense to handle stream tubes without considering the protocol of the service offered through them.</p>
<p>Connection monitoring allows fine-grained error reporting for connections made through tubes, and observing connections being made and broken even if the application code running <a class="el" href="a00383.html" title="The StreamTubeClient class is a Handler implementation for incoming Stream Tube channels, allowing an application to easily get notified about services they can connect to offered to them over Telepathy Tubes without worrying about the channel dispatching details.">StreamTubeClient</a> can't easily get this information from the code actually connecting through it. Such a setting might occur e.g. when a wrapper application is developed to connect some existing "black box" networked application through TCP tubes by launching it with the appropriate command line arguments or alike for accepted tubes.</p>
<p>Enabling connection monitoring adds a small overhead and latency to handling each incoming tube and signaling each new incoming connection over them, though, so use it only when needed.</p>
<p>A service activated Handler can be implemented using <a class="el" href="a00383.html" title="The StreamTubeClient class is a Handler implementation for incoming Stream Tube channels, allowing an application to easily get notified about services they can connect to offered to them over Telepathy Tubes without worrying about the channel dispatching details.">StreamTubeClient</a> by passing a predefined <em>clientName</em> manually to the chosen <a class="el" href="a00383.html#a46f483a430ddb98052253b28e160977b">create()</a> method, and installing Telepathy <code></code>.client and D-Bus <code></code>.service files declaring the implemented tube services as channel classes and a path to the executable. If this is not needed, the <em>clientName</em> can be omitted, in which case a random unique client name is generated and used instead. However, then the tube client application must already be running for remote contacts to be able to offer services to us over tubes.</p>
<p>Whether the Handler application implemented using <a class="el" href="a00383.html" title="The StreamTubeClient class is a Handler implementation for incoming Stream Tube channels, allowing an application to easily get notified about services they can connect to offered to them over Telepathy Tubes without worrying about the channel dispatching details.">StreamTubeClient</a> is service activatable or not, incoming channels will typically first be given to an Approver, if there is one for tube services corresponding to the tube in question. Only if the Approver decides that the tube communication should be allowed (usually by asking the user), or if there is no matching Approver at all, is the channel given to the actual Handler tube client. This can be overridden by setting <em>bypassApproval</em> to <code>true</code>, which skips approval for the given services completely and directs them straight to the Handler.</p>
<p><a class="el" href="a00383.html" title="The StreamTubeClient class is a Handler implementation for incoming Stream Tube channels, allowing an application to easily get notified about services they can connect to offered to them over Telepathy Tubes without worrying about the channel dispatching details.">StreamTubeClient</a> shares <a class="el" href="a00035.html" title="The Account class represents a Telepathy account.">Account</a>, <a class="el" href="a00127.html" title="The Connection class represents a Telepathy connection.">Connection</a> and <a class="el" href="a00077.html" title="The Channel class represents a Telepathy channel.">Channel</a> proxies and <a class="el" href="a00175.html" title="The Contact class represents a Telepathy contact.">Contact</a> objects with the rest of the application as long as a reference to the <a class="el" href="a00042.html" title="The AccountManager class represents a Telepathy account manager.">AccountManager</a>, <a class="el" href="a00125.html" title="The ClientRegistrar class is responsible for registering Telepathy clients (Observer, Approver, Handler).">ClientRegistrar</a>, or the factories used elsewhere is passed to the <a class="el" href="a00383.html#a46f483a430ddb98052253b28e160977b">create()</a> method. A stand-alone tube client Handler can get away without passing these however, or just passing select factories to make the desired features prepared and subclasses employed for these objects for their own convenience.</p>
<p>Whichever method is used, the <a class="el" href="a00086.html" title="The ChannelFactory class is responsible for constructing Channel objects according to application-def...">ChannelFactory</a> (perhaps indirectly) given must construct <a class="el" href="a00224.html" title="The IncomingStreamTubeChannel class represents an incoming Telepathy channel of type StreamTube...">IncomingStreamTubeChannel</a> instances or subclasses thereof for all channel classes corresponding to the tube services the client should be able to connect to. This is the default; overriding it without obeying these constraints using <a class="el" href="a00086.html#ad61e36911fbc08d4fafd5becece7b721">ChannelFactory::setSubclassForIncomingStreamTubes()</a> or the related methods for room tubes prevents <a class="el" href="a00383.html" title="The StreamTubeClient class is a Handler implementation for incoming Stream Tube channels, allowing an application to easily get notified about services they can connect to offered to them over Telepathy Tubes without worrying about the channel dispatching details.">StreamTubeClient</a> from operating correctly.</p>
<dl class="todo"><dt><b><a class="el" href="a00688.html#_todo000009">Todo:</a></b></dt><dd>Coin up a small Python script or alike to easily generate the .client and .service files. (fd.o #41614) </dd></dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac3a062f064bf9be0b8167de413034a4c"></a><!-- doxytag: member="Tp::StreamTubeClient::~StreamTubeClient" ref="ac3a062f064bf9be0b8167de413034a4c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tp::StreamTubeClient::~StreamTubeClient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Class destructor. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a46f483a430ddb98052253b28e160977b"></a><!-- doxytag: member="Tp::StreamTubeClient::create" ref="a46f483a430ddb98052253b28e160977b" args="(const QStringList &amp;p2pServices, const QStringList &amp;roomServices=QStringList(), const QString &amp;clientName=QString(), bool monitorConnections=false, bool bypassApproval=false, const AccountFactoryConstPtr &amp;accountFactory=AccountFactory::create(QDBusConnection::sessionBus()), const ConnectionFactoryConstPtr &amp;connectionFactory=ConnectionFactory::create(QDBusConnection::sessionBus()), const ChannelFactoryConstPtr &amp;channelFactory=ChannelFactory::create(QDBusConnection::sessionBus()), const ContactFactoryConstPtr &amp;contactFactory=ContactFactory::create())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StreamTubeClientPtr Tp::StreamTubeClient::create </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> &amp;&#160;</td>
          <td class="paramname"><em>p2pServices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> &amp;&#160;</td>
          <td class="paramname"><em>roomServices</em> = <code><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>clientName</em> = <code><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>monitorConnections</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bypassApproval</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AccountFactoryConstPtr &amp;&#160;</td>
          <td class="paramname"><em>accountFactory</em> = <code>AccountFactory::create(<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusconnection.html#sessionBus">QDBusConnection::sessionBus</a>())</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConnectionFactoryConstPtr &amp;&#160;</td>
          <td class="paramname"><em>connectionFactory</em> = <code>ConnectionFactory::create(<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusconnection.html#sessionBus">QDBusConnection::sessionBus</a>())</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ChannelFactoryConstPtr &amp;&#160;</td>
          <td class="paramname"><em>channelFactory</em> = <code>ChannelFactory::create(<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusconnection.html#sessionBus">QDBusConnection::sessionBus</a>())</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContactFactoryConstPtr &amp;&#160;</td>
          <td class="paramname"><em>contactFactory</em> = <code>ContactFactory::create()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a new <a class="el" href="a00383.html" title="The StreamTubeClient class is a Handler implementation for incoming Stream Tube channels, allowing an application to easily get notified about services they can connect to offered to them over Telepathy Tubes without worrying about the channel dispatching details.">StreamTubeClient</a>, which will register itself on the session bus using an internal <a class="el" href="a00125.html" title="The ClientRegistrar class is responsible for registering Telepathy clients (Observer, Approver, Handler).">ClientRegistrar</a> and use the given factories.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p2pServices</td><td>Names of the tube services to accept on peer-to-peer tube channels. </td></tr>
    <tr><td class="paramname">roomServices</td><td>Names of the tube services to accept on room/group tube channels. </td></tr>
    <tr><td class="paramname">clientName</td><td>The client name (without the <code>org.freedesktop.Telepathy.Client</code>. prefix). </td></tr>
    <tr><td class="paramname">monitorConnections</td><td>Whether to enable connection monitoring or not. </td></tr>
    <tr><td class="paramname">bypassApproval</td><td><code>true</code> to skip approval, <code>false</code> to invoke an Approver for incoming channels if there is one. </td></tr>
    <tr><td class="paramname">accountFactory</td><td>The account factory to use. </td></tr>
    <tr><td class="paramname">connectionFactory</td><td>The connection factory to use. </td></tr>
    <tr><td class="paramname">channelFactory</td><td>The channel factory to use. </td></tr>
    <tr><td class="paramname">contactFactory</td><td>The contact factory to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af0c745c20a295b4f2fe78ba99fbbabc4"></a><!-- doxytag: member="Tp::StreamTubeClient::create" ref="af0c745c20a295b4f2fe78ba99fbbabc4" args="(const QDBusConnection &amp;bus, const AccountFactoryConstPtr &amp;accountFactory, const ConnectionFactoryConstPtr &amp;connectionFactory, const ChannelFactoryConstPtr &amp;channelFactory, const ContactFactoryConstPtr &amp;contactFactory, const QStringList &amp;p2pServices, const QStringList &amp;roomServices=QStringList(), const QString &amp;clientName=QString(), bool monitorConnections=false, bool bypassApproval=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StreamTubeClientPtr Tp::StreamTubeClient::create </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusconnection.html">QDBusConnection</a> &amp;&#160;</td>
          <td class="paramname"><em>bus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AccountFactoryConstPtr &amp;&#160;</td>
          <td class="paramname"><em>accountFactory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConnectionFactoryConstPtr &amp;&#160;</td>
          <td class="paramname"><em>connectionFactory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ChannelFactoryConstPtr &amp;&#160;</td>
          <td class="paramname"><em>channelFactory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContactFactoryConstPtr &amp;&#160;</td>
          <td class="paramname"><em>contactFactory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> &amp;&#160;</td>
          <td class="paramname"><em>p2pServices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> &amp;&#160;</td>
          <td class="paramname"><em>roomServices</em> = <code><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>clientName</em> = <code><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>monitorConnections</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bypassApproval</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a new <a class="el" href="a00383.html" title="The StreamTubeClient class is a Handler implementation for incoming Stream Tube channels, allowing an application to easily get notified about services they can connect to offered to them over Telepathy Tubes without worrying about the channel dispatching details.">StreamTubeClient</a>, which will register itself on the given <em>bus</em> using an internal <a class="el" href="a00125.html" title="The ClientRegistrar class is responsible for registering Telepathy clients (Observer, Approver, Handler).">ClientRegistrar</a> and use the given factories.</p>
<p>The factories must all be created for the given <em>bus</em>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bus</td><td><a class="el" href="a00127.html" title="The Connection class represents a Telepathy connection.">Connection</a> to the bus to register on. </td></tr>
    <tr><td class="paramname">accountFactory</td><td>The account factory to use. </td></tr>
    <tr><td class="paramname">connectionFactory</td><td>The connection factory to use. </td></tr>
    <tr><td class="paramname">channelFactory</td><td>The channel factory to use. </td></tr>
    <tr><td class="paramname">contactFactory</td><td>The contact factory to use. </td></tr>
    <tr><td class="paramname">p2pServices</td><td>Names of the tube services to handle on peer-to-peer tube channels. </td></tr>
    <tr><td class="paramname">roomServices</td><td>Names of the tube services to handle on room/group tube channels. </td></tr>
    <tr><td class="paramname">clientName</td><td>The client name (without the <code>org.freedesktop.Telepathy.Client</code>. prefix). </td></tr>
    <tr><td class="paramname">monitorConnections</td><td>Whether to enable connection monitoring or not. </td></tr>
    <tr><td class="paramname">bypassApproval</td><td><code>true</code> to skip approval, <code>false</code> to invoke an Approver for incoming channels if there is one. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0f43076d2684766b22326b8f165deb02"></a><!-- doxytag: member="Tp::StreamTubeClient::create" ref="a0f43076d2684766b22326b8f165deb02" args="(const AccountManagerPtr &amp;accountManager, const QStringList &amp;p2pServices, const QStringList &amp;roomServices=QStringList(), const QString &amp;clientName=QString(), bool monitorConnections=false, bool bypassApproval=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StreamTubeClientPtr Tp::StreamTubeClient::create </td>
          <td>(</td>
          <td class="paramtype">const AccountManagerPtr &amp;&#160;</td>
          <td class="paramname"><em>accountManager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> &amp;&#160;</td>
          <td class="paramname"><em>p2pServices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> &amp;&#160;</td>
          <td class="paramname"><em>roomServices</em> = <code><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>clientName</em> = <code><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>monitorConnections</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bypassApproval</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a new <a class="el" href="a00383.html" title="The StreamTubeClient class is a Handler implementation for incoming Stream Tube channels, allowing an application to easily get notified about services they can connect to offered to them over Telepathy Tubes without worrying about the channel dispatching details.">StreamTubeClient</a>, which will register itself on the bus of and share objects with the given <em>accountManager</em>, creating an internal <a class="el" href="a00125.html" title="The ClientRegistrar class is responsible for registering Telepathy clients (Observer, Approver, Handler).">ClientRegistrar</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">accountManager</td><td>A pointer to the account manager to link up with. </td></tr>
    <tr><td class="paramname">p2pServices</td><td>Names of the tube services to handle on peer-to-peer tube channels. </td></tr>
    <tr><td class="paramname">roomServices</td><td>Names of the tube services to handle on room/group tube channels. </td></tr>
    <tr><td class="paramname">clientName</td><td>The client name (without the <code>org.freedesktop.Telepathy.Client</code>. prefix). </td></tr>
    <tr><td class="paramname">monitorConnections</td><td>Whether to enable connection monitoring or not. </td></tr>
    <tr><td class="paramname">bypassApproval</td><td><code>true</code> to skip approval, <code>false</code> to invoke an Approver for incoming channels if there is one. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a118bf57c77e658ee93e05b0ee31b3578"></a><!-- doxytag: member="Tp::StreamTubeClient::create" ref="a118bf57c77e658ee93e05b0ee31b3578" args="(const ClientRegistrarPtr &amp;registrar, const QStringList &amp;p2pServices, const QStringList &amp;roomServices=QStringList(), const QString &amp;clientName=QString(), bool monitorConnections=false, bool bypassApproval=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StreamTubeClientPtr Tp::StreamTubeClient::create </td>
          <td>(</td>
          <td class="paramtype">const ClientRegistrarPtr &amp;&#160;</td>
          <td class="paramname"><em>registrar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> &amp;&#160;</td>
          <td class="paramname"><em>p2pServices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> &amp;&#160;</td>
          <td class="paramname"><em>roomServices</em> = <code><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>clientName</em> = <code><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>monitorConnections</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bypassApproval</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a new <a class="el" href="a00383.html" title="The StreamTubeClient class is a Handler implementation for incoming Stream Tube channels, allowing an application to easily get notified about services they can connect to offered to them over Telepathy Tubes without worrying about the channel dispatching details.">StreamTubeClient</a>, which will register itself on the bus of and using the given client <em>registrar</em>, and share objects with it.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">registrar</td><td>The client registrar to use. </td></tr>
    <tr><td class="paramname">p2pServices</td><td>Names of the tube services to handle on peer-to-peer tube channels. </td></tr>
    <tr><td class="paramname">roomServices</td><td>Names of the tube services to handle on room/group tube channels. </td></tr>
    <tr><td class="paramname">clientName</td><td>The client name (without the <code>org.freedesktop.Telepathy.Client</code>. prefix). </td></tr>
    <tr><td class="paramname">monitorConnections</td><td>Whether to enable connection monitoring or not. </td></tr>
    <tr><td class="paramname">bypassApproval</td><td><code>true</code> to skip approval, <code>false</code> to invoke an Approver for incoming channels if there is one. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a92732661ae0a10e7f2b21b67fc4da810"></a><!-- doxytag: member="Tp::StreamTubeClient::registrar" ref="a92732661ae0a10e7f2b21b67fc4da810" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ClientRegistrarPtr Tp::StreamTubeClient::registrar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the client registrar used by the client to register itself as a Telepathy channel Handler Client.</p>
<p>This is the registrar originally passed to <a class="el" href="a00383.html#a118bf57c77e658ee93e05b0ee31b3578">create(const ClientRegistrarPtr &amp;, const QStringList &amp;, const QStringList &amp;, const QString &amp;, bool, bool)</a> if that was used, and an internally constructed one otherwise. In any case, it can be used to e.g. register further clients, just like any other <a class="el" href="a00125.html" title="The ClientRegistrar class is responsible for registering Telepathy clients (Observer, Approver, Handler).">ClientRegistrar</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the registrar. </dd></dl>

</div>
</div>
<a class="anchor" id="a09436a56bb9da91a0b8c32a476ca63be"></a><!-- doxytag: member="Tp::StreamTubeClient::clientName" ref="a09436a56bb9da91a0b8c32a476ca63be" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> Tp::StreamTubeClient::clientName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the Telepathy Client name of the client.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The name, without the <code>org.freedesktop.Telepathy.Client</code>. prefix of the full D-Bus service name. </dd></dl>

</div>
</div>
<a class="anchor" id="ac662264d218ab334f69cdd2eb62afca7"></a><!-- doxytag: member="Tp::StreamTubeClient::isRegistered" ref="ac662264d218ab334f69cdd2eb62afca7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Tp::StreamTubeClient::isRegistered </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return whether the client has been successfully registered or not.</p>
<p>Registration is attempted, at the latest, when the client is first set to accept incoming tubes, either as TCP sockets (<a class="el" href="a00383.html#abc9f3c4980b7e2b9013720b1aedde2b2">setToAcceptAsTcp()</a>) or Unix ones (<a class="el" href="a00383.html#a829e13f23dffbbb50e5af68b35b9c18f">setToAcceptAsUnix()</a>). It can fail e.g. because the connection to the bus has failed, or a predefined <em>clientName</em> has been passed to <a class="el" href="a00383.html#a46f483a430ddb98052253b28e160977b">create()</a>, and a Client with the same name is already registered. Typically, failure registering would be a fatal error for a stand-alone tube handler, but only a warning event for an application serving other purposes. In any case, a high-quality user of the API will check the return value of this accessor after choosing the desired address family.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the client has been successfully registered, <code>false</code> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a4b9fd27d1b52389492906a6054f92e9b"></a><!-- doxytag: member="Tp::StreamTubeClient::monitorsConnections" ref="a4b9fd27d1b52389492906a6054f92e9b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Tp::StreamTubeClient::monitorsConnections </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return whether connection monitoring is enabled on this client.</p>
<p>For technical reasons, connection monitoring can't be enabled when the client is already running, so there is no corresponding setter method. It has to be enabled by passing <code>true</code> as the <em>monitorConnections</em> parameter to the <a class="el" href="a00383.html#a46f483a430ddb98052253b28e160977b">create()</a> method.</p>
<p>If connection monitoring isn't enabled, <a class="el" href="a00383.html#a546354350619ba4a6e3868ad66f8059f">newConnection()</a> and <a class="el" href="a00383.html#aeaea793406ca40e9938afdd4d8c0d016">connectionClosed()</a> won't be emitted and <a class="el" href="a00383.html#a31d77a10ca40f3eb09ad506cb9c5f392">connections()</a> won't be populated.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if monitoring is enabled, <code>false</code> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a0dd9d210fd985adc19c5cf214e065244"></a><!-- doxytag: member="Tp::StreamTubeClient::acceptsAsTcp" ref="a0dd9d210fd985adc19c5cf214e065244" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Tp::StreamTubeClient::acceptsAsTcp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return whether the client is currently set to accept incoming tubes as TCP sockets.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the client will accept tubes as TCP sockets, <code>false</code> if it will accept them as Unix ones or hasn't been set to accept at all yet. </dd></dl>

</div>
</div>
<a class="anchor" id="a11aba03e2672913e71e405daea4b17da"></a><!-- doxytag: member="Tp::StreamTubeClient::tcpGenerator" ref="a11aba03e2672913e71e405daea4b17da" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00390.html">StreamTubeClient::TcpSourceAddressGenerator</a> * Tp::StreamTubeClient::tcpGenerator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the TCP source address generator, if any, set by <a class="el" href="a00383.html#abc9f3c4980b7e2b9013720b1aedde2b2">setToAcceptAsTcp()</a> previously.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the generator instance. </dd></dl>

</div>
</div>
<a class="anchor" id="a78e666ade88e771e6b1a539258622575"></a><!-- doxytag: member="Tp::StreamTubeClient::acceptsAsUnix" ref="a78e666ade88e771e6b1a539258622575" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Tp::StreamTubeClient::acceptsAsUnix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return whether the client is currently set to accept incoming tubes as Unix sockets.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the client will accept tubes as Unix sockets, <code>false</code> if it will accept them as TCP ones or hasn't been set to accept at all yet. </dd></dl>

</div>
</div>
<a class="anchor" id="abc9f3c4980b7e2b9013720b1aedde2b2"></a><!-- doxytag: member="Tp::StreamTubeClient::setToAcceptAsTcp" ref="abc9f3c4980b7e2b9013720b1aedde2b2" args="(TcpSourceAddressGenerator *generator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tp::StreamTubeClient::setToAcceptAsTcp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00390.html">TcpSourceAddressGenerator</a> *&#160;</td>
          <td class="paramname"><em>generator</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the client to accept tubes received to handle in the future in a fashion which will yield a TCP socket as the local endpoint to connect to.</p>
<p>A source address generator can optionally be set. If non-null, it will be invoked for each new tube received to handle and an attempt is made to restrict connections to the tube's local socket endpoint to those from that source address.</p>
<p>However, if the protocol backend doesn't actually support source address based access control, <a class="el" href="a00383.html#a12d4647c8ad29a941ac6123905736f92">tubeAcceptedAsTcp()</a> will be emitted with QHostAddress::Any as the allowed source address to signal that it doesn't matter where we connect from, but more importantly, that anybody else on the same host could have, and can, connect to the tube. The tube can be closed at this point if this would be unacceptable security-wise. To totally prevent the tube from being accepted in the first place, one can close it already when <a class="el" href="a00383.html#ad4d666b7d56b22c951af65021f2d9e7e">tubeOffered()</a> is emitted for it - support for the needed security mechanism can be queried using its supportsIPv4SocketsWithSpecifiedAddress() accessor.</p>
<p>The handler is registered on the bus at the latest when this method or <a class="el" href="a00383.html#a829e13f23dffbbb50e5af68b35b9c18f">setToAcceptAsUnix()</a> is called for the first time, so one should check the return value of <a class="el" href="a00383.html#ac662264d218ab334f69cdd2eb62afca7">isRegistered()</a> at that point to verify that was successful.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">generator</td><td>A pointer to the source address generator to use, or 0 to allow all connections from the local host.</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="a00688.html#_todo000010">Todo:</a></b></dt><dd>Make it possible to set the tube client to auto-close tubes if the desired access control level is not achieved, as an alternative to the current best-effort behavior. </dd></dl>

</div>
</div>
<a class="anchor" id="a829e13f23dffbbb50e5af68b35b9c18f"></a><!-- doxytag: member="Tp::StreamTubeClient::setToAcceptAsUnix" ref="a829e13f23dffbbb50e5af68b35b9c18f" args="(bool requireCredentials=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tp::StreamTubeClient::setToAcceptAsUnix </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>requireCredentials</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the client to accept tubes received to handle in the future in a fashion which will yield a Unix socket as the local endpoint to connect to.</p>
<p>If that doesn't cause problems for the payload protocol, it's possible to increase security by restricting the processes allowed to connect to the local endpoint socket to those from the same user ID as the protocol backend is running as by setting <em>requireCredentials</em> to <code>true</code>. This requires transmitting a single byte, signaled as the <em>credentialByte</em> parameter to the <a class="el" href="a00383.html#ad08bfa94a24811712e5c5ff2a1ac75bb">tubeAcceptedAsUnix()</a> signal, in a <code>SCM_CREDS</code> or SCM_CREDENTIALS message, whichever is supported by the platform, as the first thing after having connected to the socket. Even if the platform doesn't implement either concept, the byte must still be sent.</p>
<p>However, not all protocol backends support the credential passing based access control on all the platforms they can run on. If a tube is offered through such a backend, <a class="el" href="a00383.html#ad08bfa94a24811712e5c5ff2a1ac75bb">tubeAcceptedAsUnix()</a> will be emitted with <em>requiresCredentials</em> set to <code>false</code>, to signal that a credential byte should NOT be sent for that tube, and that any local process can or could have connected to the tube already. The tube can be closed at this point if this would be unacceptable security-wise. To totally prevent the tube from being accepted in the first place, one can close it already when <a class="el" href="a00383.html#ad4d666b7d56b22c951af65021f2d9e7e">tubeOffered()</a> is emitted for it - support for the needed security mechanism can be queried using its supportsIPv4SocketsWithSpecifiedAddress() accessor.</p>
<p>The handler is registered on the bus at the latest when this method or <a class="el" href="a00383.html#abc9f3c4980b7e2b9013720b1aedde2b2">setToAcceptAsTcp()</a> is called for the first time, so one should check the return value of <a class="el" href="a00383.html#ac662264d218ab334f69cdd2eb62afca7">isRegistered()</a> at that point to verify that was successful.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">requireCredentials</td><td><code>true</code> to try and restrict connecting by UID, <code>false</code> to allow all connections.</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="a00688.html#_todo000011">Todo:</a></b></dt><dd>Make it possible to set the tube client to auto-close tubes if the desired access control level is not achieved, as an alternative to the current best-effort behavior. </dd></dl>

</div>
</div>
<a class="anchor" id="a4a72d17586682c78d2cb3df358a64748"></a><!-- doxytag: member="Tp::StreamTubeClient::tubes" ref="a4a72d17586682c78d2cb3df358a64748" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qlist.html">QList</a>&lt; <a class="el" href="a00393.html">StreamTubeClient::Tube</a> &gt; Tp::StreamTubeClient::tubes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the tubes currently handled by the client.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A list of <a class="el" href="a00393.html" title="The StreamTubeClient::Tube class represents a tube being handled by the client.">Tube</a> structures containing pointers to the account and tube channel for each tube. </dd></dl>

</div>
</div>
<a class="anchor" id="a31d77a10ca40f3eb09ad506cb9c5f392"></a><!-- doxytag: member="Tp::StreamTubeClient::connections" ref="a31d77a10ca40f3eb09ad506cb9c5f392" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qhash.html">QHash</a>&lt; <a class="el" href="a00393.html">StreamTubeClient::Tube</a>, <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qset.html">QSet</a>&lt; uint &gt; &gt; Tp::StreamTubeClient::connections </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the ongoing connections established through tubes signaled by this client.</p>
<p>The returned mapping has for each <a class="el" href="a00393.html" title="The StreamTubeClient::Tube class represents a tube being handled by the client.">Tube</a> a structure containing pointers to the account and tube channel objects as keys, with the integer identifiers for the current connections on them as the values. The IDs are unique amongst the connections active on a single tube at any given time, but not globally.</p>
<p>This is effectively a state recovery accessor corresponding to the change notification signals <a class="el" href="a00383.html#a546354350619ba4a6e3868ad66f8059f">newConnection()</a> and <a class="el" href="a00383.html#aeaea793406ca40e9938afdd4d8c0d016">connectionClosed()</a>.</p>
<p>The mapping is only populated if connection monitoring was requested when creating the client (so <a class="el" href="a00383.html#a4b9fd27d1b52389492906a6054f92e9b">monitorsConnections()</a> returns <code>true</code>).</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The connections in a mapping with <a class="el" href="a00393.html" title="The StreamTubeClient::Tube class represents a tube being handled by the client.">Tube</a> structures containing pointers to the account and channel objects for each tube as keys, and the sets of numerical IDs as values. </dd></dl>

</div>
</div>
<a class="anchor" id="ad4d666b7d56b22c951af65021f2d9e7e"></a><!-- doxytag: member="Tp::StreamTubeClient::tubeOffered" ref="ad4d666b7d56b22c951af65021f2d9e7e" args="(const Tp::AccountPtr &amp;account, const Tp::IncomingStreamTubeChannelPtr &amp;tube)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tp::StreamTubeClient::tubeOffered </td>
          <td>(</td>
          <td class="paramtype">const Tp::AccountPtr &amp;&#160;</td>
          <td class="paramname"><em>account</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tp::IncomingStreamTubeChannelPtr &amp;&#160;</td>
          <td class="paramname"><em>tube</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Emitted when one of the services we're interested in connecting to has been offered by us as a tube, which we've began handling.</p>
<p>This is emitted before invoking the <a class="el" href="a00390.html" title="The StreamTubeClient::TcpSourceAddressGenerator abstract interface allows using socket source address...">TcpSourceAddressGenerator</a>, if any, for the tube.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">account</td><td>A pointer to the account through which the tube was offered. </td></tr>
    <tr><td class="paramname">tube</td><td>A pointer to the actual tube channel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab8b5d535d458e1d0204fe1612b5280b2"></a><!-- doxytag: member="Tp::StreamTubeClient::tubeClosed" ref="ab8b5d535d458e1d0204fe1612b5280b2" args="(const Tp::AccountPtr &amp;account, const Tp::IncomingStreamTubeChannelPtr &amp;tube, const QString &amp;error, const QString &amp;message)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tp::StreamTubeClient::tubeClosed </td>
          <td>(</td>
          <td class="paramtype">const Tp::AccountPtr &amp;&#160;</td>
          <td class="paramname"><em>account</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tp::IncomingStreamTubeChannelPtr &amp;&#160;</td>
          <td class="paramname"><em>tube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Emitted when a tube we've been handling (previously announced with <a class="el" href="a00383.html#ad4d666b7d56b22c951af65021f2d9e7e">tubeOffered()</a>) has encountered an error or has otherwise been closed from further communication.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">account</td><td>A pointer to the account through which the tube was offered. </td></tr>
    <tr><td class="paramname">tube</td><td>A pointer to the actual tube channel. </td></tr>
    <tr><td class="paramname">error</td><td>The D-Bus error name corresponding to the reason for the closure. </td></tr>
    <tr><td class="paramname">message</td><td>A freeform debug message associated with the error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a12d4647c8ad29a941ac6123905736f92"></a><!-- doxytag: member="Tp::StreamTubeClient::tubeAcceptedAsTcp" ref="a12d4647c8ad29a941ac6123905736f92" args="(const QHostAddress &amp;listenAddress, quint16 listenPort, const QHostAddress &amp;sourceAddress, quint16 sourcePort, const Tp::AccountPtr &amp;account, const Tp::IncomingStreamTubeChannelPtr &amp;tube)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tp::StreamTubeClient::tubeAcceptedAsTcp </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qhostaddress.html">QHostAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>listenAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">quint16&#160;</td>
          <td class="paramname"><em>listenPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qhostaddress.html">QHostAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">quint16&#160;</td>
          <td class="paramname"><em>sourcePort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tp::AccountPtr &amp;&#160;</td>
          <td class="paramname"><em>account</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tp::IncomingStreamTubeChannelPtr &amp;&#160;</td>
          <td class="paramname"><em>tube</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Emitted when a tube offered to us (previously announced with <a class="el" href="a00383.html#ad4d666b7d56b22c951af65021f2d9e7e">tubeOffered()</a>) has been successfully accepted and a TCP socket established as the local endpoint, as specified by <a class="el" href="a00383.html#abc9f3c4980b7e2b9013720b1aedde2b2">setToAcceptAsTcp()</a>.</p>
<p>The allowed source address and port are signaled here if there was a <a class="el" href="a00390.html" title="The StreamTubeClient::TcpSourceAddressGenerator abstract interface allows using socket source address...">TcpSourceAddressGenerator</a> set at the time of accepting this tube, it yielded a non-zero address, and the protocol backend supports source address based access control. This enables the application to use the correct one of the sockets it currently has bound to the generated addresses.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">listenAddress</td><td>The listen address of the local endpoint socket. </td></tr>
    <tr><td class="paramname">listenPort</td><td>The listen port of the local endpoint socket. </td></tr>
    <tr><td class="paramname">sourceAddress</td><td>The host address allowed to connect to the tube, or QHostAddress::Any if source address based access control is not in use. </td></tr>
    <tr><td class="paramname">sourcePort</td><td>The port from which connections are allowed to the tube, or 0 if source address based access control is not in use. </td></tr>
    <tr><td class="paramname">account</td><td>A pointer to the account object through which the tube was offered. </td></tr>
    <tr><td class="paramname">tube</td><td>A pointer to the actual tube channel object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad08bfa94a24811712e5c5ff2a1ac75bb"></a><!-- doxytag: member="Tp::StreamTubeClient::tubeAcceptedAsUnix" ref="ad08bfa94a24811712e5c5ff2a1ac75bb" args="(const QString &amp;listenAddress, bool requiresCredentials, uchar credentialByte, const Tp::AccountPtr &amp;account, const Tp::IncomingStreamTubeChannelPtr &amp;tube)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tp::StreamTubeClient::tubeAcceptedAsUnix </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>listenAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>requiresCredentials</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar&#160;</td>
          <td class="paramname"><em>credentialByte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tp::AccountPtr &amp;&#160;</td>
          <td class="paramname"><em>account</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tp::IncomingStreamTubeChannelPtr &amp;&#160;</td>
          <td class="paramname"><em>tube</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Emitted when a tube offered to us (previously announced with <a class="el" href="a00383.html#ad4d666b7d56b22c951af65021f2d9e7e">tubeOffered()</a>) has been successfully accepted and a Unix socket established as the local endpoint, as specified by <a class="el" href="a00383.html#a829e13f23dffbbb50e5af68b35b9c18f">setToAcceptAsUnix()</a>.</p>
<p>The credential byte which should be sent after connecting to the tube (in a SCM_CREDENTIALS or SCM_CREDS message if supported by the platform) will be signaled here if the client was set to attempt requiring credentials at the time of accepting this tube, and the protocol backend supports credential passing based access control. Otherwise, <em>requiresCredentials</em> will be false and no byte or associated out-of-band credentials metadata should be sent.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">listenAddress</td><td>The listen address of the local endpoint socket. </td></tr>
    <tr><td class="paramname">requiresCredentials</td><td><code>true</code> if <em>credentialByte</em> should be sent after connecting to the socket, <code>false</code> if not. </td></tr>
    <tr><td class="paramname">credentialByte</td><td>The byte to send if <em>requiresCredentials</em> is <code>true</code>. </td></tr>
    <tr><td class="paramname">account</td><td>A pointer to the account object through which the tube was offered. </td></tr>
    <tr><td class="paramname">tube</td><td>A pointer to the actual tube channel object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a546354350619ba4a6e3868ad66f8059f"></a><!-- doxytag: member="Tp::StreamTubeClient::newConnection" ref="a546354350619ba4a6e3868ad66f8059f" args="(const Tp::AccountPtr &amp;account, const Tp::IncomingStreamTubeChannelPtr &amp;tube, uint connectionId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tp::StreamTubeClient::newConnection </td>
          <td>(</td>
          <td class="paramtype">const Tp::AccountPtr &amp;&#160;</td>
          <td class="paramname"><em>account</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tp::IncomingStreamTubeChannelPtr &amp;&#160;</td>
          <td class="paramname"><em>tube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>connectionId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Emitted when a new connection has been made to the local endpoint socket for <em>tube</em>.</p>
<p>This can be used to later associate connection errors reported by <a class="el" href="a00383.html#aeaea793406ca40e9938afdd4d8c0d016">connectionClosed()</a> with the corresponding application sockets. However, establishing the association generally requires connecting only one socket at a time, waiting for <a class="el" href="a00383.html#a546354350619ba4a6e3868ad66f8059f">newConnection()</a> to be emitted, and only then proceeding, as there is no identification for the connections unlike the incoming connections in <a class="el" href="a00384.html" title="The StreamTubeServer class is a Handler implementation for outgoing Stream Tube channels, allowing an application to easily export a TCP network server over Telepathy Tubes without worrying about the channel dispatching details.">StreamTubeServer</a>.</p>
<p>Note that the connection IDs are only unique within a given tube, so identification of the tube channel must also be recorded together with the ID to establish global uniqueness. Even then, the a connection ID can be reused after the previous connection identified by it having been signaled as closed with <a class="el" href="a00383.html#aeaea793406ca40e9938afdd4d8c0d016">connectionClosed()</a>.</p>
<p>This is only emitted if connection monitoring was enabled when creating the <a class="el" href="a00383.html" title="The StreamTubeClient class is a Handler implementation for incoming Stream Tube channels, allowing an application to easily get notified about services they can connect to offered to them over Telepathy Tubes without worrying about the channel dispatching details.">StreamTubeClient</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">account</td><td>A pointer to the account through which the tube was offered. </td></tr>
    <tr><td class="paramname">tube</td><td>A pointer to the tube channel through which the connection has been made. </td></tr>
    <tr><td class="paramname">connectionId</td><td>The integer ID of the new connection. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeaea793406ca40e9938afdd4d8c0d016"></a><!-- doxytag: member="Tp::StreamTubeClient::connectionClosed" ref="aeaea793406ca40e9938afdd4d8c0d016" args="(const Tp::AccountPtr &amp;account, const Tp::IncomingStreamTubeChannelPtr &amp;tube, uint connectionId, const QString &amp;error, const QString &amp;message)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tp::StreamTubeClient::connectionClosed </td>
          <td>(</td>
          <td class="paramtype">const Tp::AccountPtr &amp;&#160;</td>
          <td class="paramname"><em>account</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tp::IncomingStreamTubeChannelPtr &amp;&#160;</td>
          <td class="paramname"><em>tube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>connectionId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Emitted when a connection (previously announced with <a class="el" href="a00383.html#a546354350619ba4a6e3868ad66f8059f">newConnection()</a>) through one of our handled tubes has been closed due to an error or by a graceful disconnect (in which case the error is <a class="el" href="a00683.html#ga75667bac6c21222c3b8e1d187e6140f7">TP_QT4_ERROR_CANCELLED</a>).</p>
<p>This is only emitted if connection monitoring was enabled when creating the <a class="el" href="a00383.html" title="The StreamTubeClient class is a Handler implementation for incoming Stream Tube channels, allowing an application to easily get notified about services they can connect to offered to them over Telepathy Tubes without worrying about the channel dispatching details.">StreamTubeClient</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">account</td><td>A pointer to the account through which the tube was offered. </td></tr>
    <tr><td class="paramname">tube</td><td>A pointer to the tube channel through which the connection had been made. </td></tr>
    <tr><td class="paramname">connectionId</td><td>The integer ID of the connection closed. </td></tr>
    <tr><td class="paramname">error</td><td>The D-Bus error name corresponding to the reason for the closure. </td></tr>
    <tr><td class="paramname">message</td><td>A freeform debug message associated with the error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td width="30%">Copyright &copy; 2008-2011 Collabora Ltd. and Nokia Corporation</td>
<td width="30%" align="right"><div align="right">Telepathy-Qt4 0.8.0</div></td>
</tr></table></div></address>
</body>
</html>
