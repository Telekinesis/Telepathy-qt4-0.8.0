<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Tp::Client::AccountInterface Class Reference</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td width="1">&nbsp;&nbsp;</td>
<td class="postheader" valign="center">
<a href="index.html">
<font color="#004faf">Home</font></a>&nbsp;&middot;
<a href="classes.html">
<font color="#004faf">All Classes</font></a>&nbsp;&middot;
<a href="namespaces.html">
<font color="#004faf">All Namespaces</font></a>&nbsp;&middot;
<a href="modules.html">
<font color="#004faf">Modules</font></a>&nbsp;&middot;
<a href="functions.html">
<font color="#004faf">Functions</font></a>&nbsp;&middot;
<a href="files.html">
<font color="#004faf">Files</font></a>
</td>
</tr>
</table>
<!-- Generated by Doxygen 1.7.5 -->
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="a00655.html">Tp</a>      </li>
      <li class="navelem"><a class="el" href="a00659.html">Client</a>      </li>
      <li class="navelem"><a class="el" href="a00038.html">AccountInterface</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-slots">Public Slots</a> &#124;
<a href="#signals">Signals</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">Tp::Client::AccountInterface Class Reference<div class="ingroups"><a class="el" href="a00665.html">Account proxies</a></div></div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Tp::Client::AccountInterface" --><!-- doxytag: inherits="Tp::AbstractInterface" -->
<p><code>#include &lt;<a class="el" href="a00453_source.html">TelepathyQt4/AccountManager</a>&gt;</code></p>

<p>Inherits <a class="el" href="a00033.html">Tp::AbstractInterface</a>.</p>

<p><a href="a00912.html">List of all members.</a></p>
<h2><a name="pub-slots"></a>
Public Slots</h2>
<ul>
<li><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbuspendingreply.html">QDBusPendingReply</a> <a class="el" href="a00038.html#aafff9e9364c41883b86e508eae1b6d1e">Remove</a> (int <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusabstractinterface.html#timeout">timeout</a>=-1)
<li><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbuspendingreply.html">QDBusPendingReply</a>&lt; <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> &gt; <a class="el" href="a00038.html#a3ba5ad3cfa9a002bb2c66c74104ad532">UpdateParameters</a> (const QVariantMap &amp;set, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> &amp;unset, int <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusabstractinterface.html#timeout">timeout</a>=-1)
<li><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbuspendingreply.html">QDBusPendingReply</a> <a class="el" href="a00038.html#a67dde6a908c5e44c599c6816ab0cf8a8">Reconnect</a> (int <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusabstractinterface.html#timeout">timeout</a>=-1)
</ul>
<h2><a name="signals"></a>
Signals</h2>
<ul>
<li>void <a class="el" href="a00038.html#ac54562f56877c69c4a3d27ca758cf8fd">Removed</a> ()
<li>void <a class="el" href="a00038.html#ab1c040e758a3af7da14fc3f570f24a40">AccountPropertyChanged</a> (const QVariantMap &amp;properties)
</ul>
<h2><a name="pub-methods"></a>
Public Member Functions</h2>
<ul>
<li><a class="el" href="a00038.html#ae31d2650076d6b4b4d89906d6c71a4bc">AccountInterface</a> (const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;busName, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;objectPath, <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qobject.html">QObject</a> *<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qobject.html#parent">parent</a>=0)
<li><a class="el" href="a00038.html#a8436989210e6335be512001bc8654f2e">AccountInterface</a> (const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusconnection.html">QDBusConnection</a> &amp;<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusabstractinterface.html#connection">connection</a>, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;busName, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;objectPath, <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qobject.html">QObject</a> *<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qobject.html#parent">parent</a>=0)
<li><a class="el" href="a00038.html#add59859f573579959b72f2a402ff5c6a">AccountInterface</a> (<a class="el" href="a00195.html">Tp::DBusProxy</a> *proxy)
<li><a class="el" href="a00309.html">Tp::PendingVariant</a> * <a class="el" href="a00038.html#ac092a1717f929f7db1aaffaccb564479">requestPropertyInterfaces</a> () const 
<li><a class="el" href="a00309.html">Tp::PendingVariant</a> * <a class="el" href="a00038.html#a4d8023273f270922b59493f23ca2a221">requestPropertyDisplayName</a> () const 
<li><a class="el" href="a00301.html">Tp::PendingOperation</a> * <a class="el" href="a00038.html#a27adff0d773158bbe81340aa4dac8a27">setPropertyDisplayName</a> (<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> newValue)
<li><a class="el" href="a00309.html">Tp::PendingVariant</a> * <a class="el" href="a00038.html#a7b797f4cf85678499338df91d18d8ed6">requestPropertyIcon</a> () const 
<li><a class="el" href="a00301.html">Tp::PendingOperation</a> * <a class="el" href="a00038.html#ab18a3c398ae4e5fef39b784dd9a54649">setPropertyIcon</a> (<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> newValue)
<li><a class="el" href="a00309.html">Tp::PendingVariant</a> * <a class="el" href="a00038.html#ac91ef67bd0fe78f6b55159315a29bb81">requestPropertyValid</a> () const 
<li><a class="el" href="a00309.html">Tp::PendingVariant</a> * <a class="el" href="a00038.html#a1ea9fbd2a42882e47ebb70c8fb300845">requestPropertyEnabled</a> () const 
<li><a class="el" href="a00301.html">Tp::PendingOperation</a> * <a class="el" href="a00038.html#ac4b9ce97170a52ac579b2c0d59a5586f">setPropertyEnabled</a> (bool newValue)
<li><a class="el" href="a00309.html">Tp::PendingVariant</a> * <a class="el" href="a00038.html#a90018ec9de59a0d8e3949995dfdc084c">requestPropertyNickname</a> () const 
<li><a class="el" href="a00301.html">Tp::PendingOperation</a> * <a class="el" href="a00038.html#a1bff26528d1f9793e0d528f70ad9da2c">setPropertyNickname</a> (<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> newValue)
<li><a class="el" href="a00309.html">Tp::PendingVariant</a> * <a class="el" href="a00038.html#ae9040da7b193ea9597fff03f9fa5422d">requestPropertyService</a> () const 
<li><a class="el" href="a00301.html">Tp::PendingOperation</a> * <a class="el" href="a00038.html#a69c80a9cb0077671630c73c0cfff5c34">setPropertyService</a> (<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> newValue)
<li><a class="el" href="a00309.html">Tp::PendingVariant</a> * <a class="el" href="a00038.html#a3bba5536ec20e444de1048db449aa981">requestPropertyParameters</a> () const 
<li><a class="el" href="a00309.html">Tp::PendingVariant</a> * <a class="el" href="a00038.html#a05b1a012789347f54c8aa65badd91922">requestPropertyAutomaticPresence</a> () const 
<li><a class="el" href="a00301.html">Tp::PendingOperation</a> * <a class="el" href="a00038.html#a40662d9b543e60e45a874751e47d2a5e">setPropertyAutomaticPresence</a> (<a class="el" href="a00364.html">Tp::SimplePresence</a> newValue)
<li><a class="el" href="a00309.html">Tp::PendingVariant</a> * <a class="el" href="a00038.html#a1b3df420b6dd256f3246bbe9a283f761">requestPropertyConnectAutomatically</a> () const 
<li><a class="el" href="a00301.html">Tp::PendingOperation</a> * <a class="el" href="a00038.html#aff2365221bd8ec0cbcac24aa104cef31">setPropertyConnectAutomatically</a> (bool newValue)
<li><a class="el" href="a00309.html">Tp::PendingVariant</a> * <a class="el" href="a00038.html#aac5de300678dcb2b3632a06a51954ec0">requestPropertyConnection</a> () const 
<li><a class="el" href="a00309.html">Tp::PendingVariant</a> * <a class="el" href="a00038.html#aa96d364028e5a1bf9438552e6d6c6d6c">requestPropertyConnectionStatus</a> () const 
<li><a class="el" href="a00309.html">Tp::PendingVariant</a> * <a class="el" href="a00038.html#aac277a5402c90ffc4d7891fecea13ab4">requestPropertyConnectionStatusReason</a> () const 
<li><a class="el" href="a00309.html">Tp::PendingVariant</a> * <a class="el" href="a00038.html#a7c23434905a5a83069a752620562ac62">requestPropertyConnectionError</a> () const 
<li><a class="el" href="a00309.html">Tp::PendingVariant</a> * <a class="el" href="a00038.html#a2887994607dffcdc98696a0ce2711fc0">requestPropertyConnectionErrorDetails</a> () const 
<li><a class="el" href="a00309.html">Tp::PendingVariant</a> * <a class="el" href="a00038.html#a9e6d071253895146d85eb8f315b7eec2">requestPropertyCurrentPresence</a> () const 
<li><a class="el" href="a00309.html">Tp::PendingVariant</a> * <a class="el" href="a00038.html#a38e8810907a6bfcf368ecf2a4d28cba2">requestPropertyRequestedPresence</a> () const 
<li><a class="el" href="a00301.html">Tp::PendingOperation</a> * <a class="el" href="a00038.html#adf6efd445e74a91fce805da68acd8d6a">setPropertyRequestedPresence</a> (<a class="el" href="a00364.html">Tp::SimplePresence</a> newValue)
<li><a class="el" href="a00309.html">Tp::PendingVariant</a> * <a class="el" href="a00038.html#a75c501194be615df752ba7df0c487d25">requestPropertyChangingPresence</a> () const 
<li><a class="el" href="a00309.html">Tp::PendingVariant</a> * <a class="el" href="a00038.html#a9aea7ff6df329438b2a4937686d20219">requestPropertyNormalizedName</a> () const 
<li><a class="el" href="a00309.html">Tp::PendingVariant</a> * <a class="el" href="a00038.html#a4c3d8e27c21236ad39eb3bddac2c46f4">requestPropertyHasBeenOnline</a> () const 
<li><a class="el" href="a00310.html">Tp::PendingVariantMap</a> * <a class="el" href="a00038.html#ab72bdbe9b6f425a75beddc06a1f4b992">requestAllProperties</a> () const 
</ul>
<h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2>
<ul>
<li>static <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qlatin1string.html">QLatin1String</a> <a class="el" href="a00038.html#a78754208dfe803627327780459d485fb">staticInterfaceName</a> ()
</ul>
<h2><a name="pro-methods"></a>
Protected Member Functions</h2>
<ul>
<li>virtual void <a class="el" href="a00038.html#a3d919b1b4c69abf8f8f221cddf6d9780">invalidate</a> (<a class="el" href="a00195.html">Tp::DBusProxy</a> *, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;)
</ul>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Account." </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae31d2650076d6b4b4d89906d6c71a4bc"></a><!-- doxytag: member="Tp::Client::AccountInterface::AccountInterface" ref="ae31d2650076d6b4b4d89906d6c71a4bc" args="(const QString &amp;busName, const QString &amp;objectPath, QObject *parent=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tp::Client::AccountInterface::AccountInterface </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>busName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>objectPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qobject.html">QObject</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a <a class="el" href="a00038.html">AccountInterface</a> associated with the given object on the session bus.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">busName</td><td>Name of the service the object is on. </td></tr>
    <tr><td class="paramname">objectPath</td><td>Path to the object on the service. </td></tr>
    <tr><td class="paramname">parent</td><td>Passed to the parent class constructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8436989210e6335be512001bc8654f2e"></a><!-- doxytag: member="Tp::Client::AccountInterface::AccountInterface" ref="a8436989210e6335be512001bc8654f2e" args="(const QDBusConnection &amp;connection, const QString &amp;busName, const QString &amp;objectPath, QObject *parent=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tp::Client::AccountInterface::AccountInterface </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusconnection.html">QDBusConnection</a> &amp;&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>busName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>objectPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qobject.html">QObject</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a <a class="el" href="a00038.html">AccountInterface</a> associated with the given object on the given bus.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">connection</td><td>The bus via which the object can be reached. </td></tr>
    <tr><td class="paramname">busName</td><td>Name of the service the object is on. </td></tr>
    <tr><td class="paramname">objectPath</td><td>Path to the object on the service. </td></tr>
    <tr><td class="paramname">parent</td><td>Passed to the parent class constructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="add59859f573579959b72f2a402ff5c6a"></a><!-- doxytag: member="Tp::Client::AccountInterface::AccountInterface" ref="add59859f573579959b72f2a402ff5c6a" args="(Tp::DBusProxy *proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tp::Client::AccountInterface::AccountInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00195.html">Tp::DBusProxy</a> *&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a <a class="el" href="a00038.html">AccountInterface</a> associated with the same object as the given proxy.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The proxy to use. It will also be the <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qobject.html#parent">QObject::parent()</a> for this object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a78754208dfe803627327780459d485fb"></a><!-- doxytag: member="Tp::Client::AccountInterface::staticInterfaceName" ref="a78754208dfe803627327780459d485fb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qlatin1string.html">QLatin1String</a> Tp::Client::AccountInterface::staticInterfaceName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the name of the interface "org.freedesktop.Telepathy.Account", which this class represents.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The D-Bus interface name. </dd></dl>

</div>
</div>
<a class="anchor" id="ac092a1717f929f7db1aaffaccb564479"></a><!-- doxytag: member="Tp::Client::AccountInterface::requestPropertyInterfaces" ref="ac092a1717f929f7db1aaffaccb564479" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00309.html">Tp::PendingVariant</a>* Tp::Client::AccountInterface::requestPropertyInterfaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property <code>Interfaces</code> of type <code><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a></code>.</p>
<p>A list of the extra interfaces provided by this account.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="a4d8023273f270922b59493f23ca2a221"></a><!-- doxytag: member="Tp::Client::AccountInterface::requestPropertyDisplayName" ref="a4d8023273f270922b59493f23ca2a221" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00309.html">Tp::PendingVariant</a>* Tp::Client::AccountInterface::requestPropertyDisplayName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property <code>DisplayName</code> of type <code><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a></code>.</p>
<p>The user-visible name of this account. This SHOULD be chosen by the user at account creation time. The account creation user interface is responsible for setting a reasonable default value in the user's locale; something like "Jabber (<a href="mailto:bob@example.com">bob@example.com</a>)" would be sensible.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="a27adff0d773158bbe81340aa4dac8a27"></a><!-- doxytag: member="Tp::Client::AccountInterface::setPropertyDisplayName" ref="a27adff0d773158bbe81340aa4dac8a27" args="(QString newValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00301.html">Tp::PendingOperation</a>* Tp::Client::AccountInterface::setPropertyDisplayName </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a>&#160;</td>
          <td class="paramname"><em>newValue</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous setter for the remote object property <code>DisplayName</code> of type <code><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a></code>.</p>
<p>The user-visible name of this account. This SHOULD be chosen by the user at account creation time. The account creation user interface is responsible for setting a reasonable default value in the user's locale; something like "Jabber (<a href="mailto:bob@example.com">bob@example.com</a>)" would be sensible.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pending operation which will emit finished when the property has been set. </dd></dl>

</div>
</div>
<a class="anchor" id="a7b797f4cf85678499338df91d18d8ed6"></a><!-- doxytag: member="Tp::Client::AccountInterface::requestPropertyIcon" ref="a7b797f4cf85678499338df91d18d8ed6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00309.html">Tp::PendingVariant</a>* Tp::Client::AccountInterface::requestPropertyIcon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property <code>Icon</code> of type <code><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a></code>.</p>
<p>The name of an icon in the system's icon theme, such as "im-msn", or the empty string to not specify an icon. If the icon is set to an empty string, the account manager or any client MAY derive a default icon, for instance from the protocol.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="ab18a3c398ae4e5fef39b784dd9a54649"></a><!-- doxytag: member="Tp::Client::AccountInterface::setPropertyIcon" ref="ab18a3c398ae4e5fef39b784dd9a54649" args="(QString newValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00301.html">Tp::PendingOperation</a>* Tp::Client::AccountInterface::setPropertyIcon </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a>&#160;</td>
          <td class="paramname"><em>newValue</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous setter for the remote object property <code>Icon</code> of type <code><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a></code>.</p>
<p>The name of an icon in the system's icon theme, such as "im-msn", or the empty string to not specify an icon. If the icon is set to an empty string, the account manager or any client MAY derive a default icon, for instance from the protocol.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pending operation which will emit finished when the property has been set. </dd></dl>

</div>
</div>
<a class="anchor" id="ac91ef67bd0fe78f6b55159315a29bb81"></a><!-- doxytag: member="Tp::Client::AccountInterface::requestPropertyValid" ref="ac91ef67bd0fe78f6b55159315a29bb81" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00309.html">Tp::PendingVariant</a>* Tp::Client::AccountInterface::requestPropertyValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property <code>Valid</code> of type <code>bool</code>.</p>
<p>If true, this account is considered by the account manager to be complete and usable. If false, user action is required to make it usable, and it will never attempt to connect (for instance, this might be caused by the absence of a required parameter). For connection managers with a plugin architecture, like telepathy-haze, we have little or no control over the parameters offered; for platforms with package management, we have little or no control over the CMs offered. NMC 4.x would just pretend the account didn't exist in these circumstances, but silent data loss is bad, and UIs with CM-specific knowledge (or a user filling in newly-required parameters) might be able to rescue a broken account.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ea9fbd2a42882e47ebb70c8fb300845"></a><!-- doxytag: member="Tp::Client::AccountInterface::requestPropertyEnabled" ref="a1ea9fbd2a42882e47ebb70c8fb300845" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00309.html">Tp::PendingVariant</a>* Tp::Client::AccountInterface::requestPropertyEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property <code>Enabled</code> of type <code>bool</code>.</p>
 
 <p>This property gives the users the possibility to prevent an account
   from being used. This flag does not change the validity of the
   account.</p>
 
 <p>A disabled account can never be put online.</p>
 
 <div class="rationale">
   <p>Use cases:</p>
 
   <ul>
     <li>user has two or more accounts capable of calling contact X, but
       he doesn't want the UI to prompt him everytime about which one he
       wants to use for the call. He can then disable all the equivalent
       accounts but one.</li>
 
     <li>There is some temporary server error and the user doesn't want
       to be be bother by error messages, or change the account
       configuration: temporarily disabling the account is quicker.</li>
   </ul>
 </div>
 
 <p>The AccountManager SHOULD allow this property to be set on invalid
   accounts, but MUST NOT attempt to put invalid accounts online
   even if they become Enabled.</p>
 
 <div class="rationale">
   <p>There doesn't seem to be any good reason not to allow this.</p>
 </div>
 <dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="ac4b9ce97170a52ac579b2c0d59a5586f"></a><!-- doxytag: member="Tp::Client::AccountInterface::setPropertyEnabled" ref="ac4b9ce97170a52ac579b2c0d59a5586f" args="(bool newValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00301.html">Tp::PendingOperation</a>* Tp::Client::AccountInterface::setPropertyEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>newValue</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous setter for the remote object property <code>Enabled</code> of type <code>bool</code>.</p>
 
 <p>This property gives the users the possibility to prevent an account
   from being used. This flag does not change the validity of the
   account.</p>
 
 <p>A disabled account can never be put online.</p>
 
 <div class="rationale">
   <p>Use cases:</p>
 
   <ul>
     <li>user has two or more accounts capable of calling contact X, but
       he doesn't want the UI to prompt him everytime about which one he
       wants to use for the call. He can then disable all the equivalent
       accounts but one.</li>
 
     <li>There is some temporary server error and the user doesn't want
       to be be bother by error messages, or change the account
       configuration: temporarily disabling the account is quicker.</li>
   </ul>
 </div>
 
 <p>The AccountManager SHOULD allow this property to be set on invalid
   accounts, but MUST NOT attempt to put invalid accounts online
   even if they become Enabled.</p>
 
 <div class="rationale">
   <p>There doesn't seem to be any good reason not to allow this.</p>
 </div>
 <dl class="return"><dt><b>Returns:</b></dt><dd>A pending operation which will emit finished when the property has been set. </dd></dl>

</div>
</div>
<a class="anchor" id="a90018ec9de59a0d8e3949995dfdc084c"></a><!-- doxytag: member="Tp::Client::AccountInterface::requestPropertyNickname" ref="a90018ec9de59a0d8e3949995dfdc084c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00309.html">Tp::PendingVariant</a>* Tp::Client::AccountInterface::requestPropertyNickname </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property <code>Nickname</code> of type <code><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a></code>.</p>
<p>The nickname to set on this account for display to other contacts, as set by the user. When the account becomes connected, the account manager SHOULD set this as the user's alias using SetAliases if appropriate. In a later specification revision, we plan to separate the concepts of a contact's nickname as set by themselves, and the local name for them in our contact list (a "handle" or "pet name" as described in XEP-0165 and its references). The terminology change from alias to nickname here is a step in that direction.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="a1bff26528d1f9793e0d528f70ad9da2c"></a><!-- doxytag: member="Tp::Client::AccountInterface::setPropertyNickname" ref="a1bff26528d1f9793e0d528f70ad9da2c" args="(QString newValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00301.html">Tp::PendingOperation</a>* Tp::Client::AccountInterface::setPropertyNickname </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a>&#160;</td>
          <td class="paramname"><em>newValue</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous setter for the remote object property <code>Nickname</code> of type <code><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a></code>.</p>
<p>The nickname to set on this account for display to other contacts, as set by the user. When the account becomes connected, the account manager SHOULD set this as the user's alias using SetAliases if appropriate. In a later specification revision, we plan to separate the concepts of a contact's nickname as set by themselves, and the local name for them in our contact list (a "handle" or "pet name" as described in XEP-0165 and its references). The terminology change from alias to nickname here is a step in that direction.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pending operation which will emit finished when the property has been set. </dd></dl>

</div>
</div>
<a class="anchor" id="ae9040da7b193ea9597fff03f9fa5422d"></a><!-- doxytag: member="Tp::Client::AccountInterface::requestPropertyService" ref="ae9040da7b193ea9597fff03f9fa5422d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00309.html">Tp::PendingVariant</a>* Tp::Client::AccountInterface::requestPropertyService </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property <code>Service</code> of type <code><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a></code>.</p>
 
 <p>Some protocols, like XMPP and SIP, are used by various different
   user-recognised brands, such as <i>Google Talk</i> and <i>Ovi by
   Nokia</i>. On accounts for such services, this property SHOULD be
   set to a string describing the service, which MUST consist only of
   ASCII letters, numbers and hyphen/minus signs, and start with a
   letter (matching the requirements for <tp:type>Protocol</tp:type>).
   For the <tt>jabber</tt> protocol, one of the following service names
   should be used if possible:</p>
 
 <ul>
   <li><tt>google-talk</tt> (for <a href="http://www.google.com/talk/">Google's IM service</a>)</li>
   <li><tt>ovi-chat</tt> (for <a href="http://www.ovi.com/">Ovi</a>'s IM
     service)</li>
   <li><tt>facebook</tt> (for <a href="http://www.facebook.com/sitetour/chat.php">Facebook's IM
     service</a>)</li>
   <li><tt>lj-talk</tt> (for <a href="http://www.livejournal.com/chat/">LiveJournal's IM
     service</a>)</li>
 
 </ul>
 
 <p>The   <a class="el" href="a00038.html#a7b797f4cf85678499338df91d18d8ed6">Icon </a>  property SHOULD be set to a
   corresponding brand-specific icon name, if possible. In the future,
   this property may be used as an index into additional
   service-specific customizations. If this property is the empty string
   (or missing), the service is determined by the protocol name (either
   because this is a single-service protocol like <tt>msn</tt>, or
   because this is just a generic <tt>jabber</tt> or <tt>sip</tt>
   account without specific branding).</p>
 
 <p>This property MAY be set, if appropriate, when calling
     <a class="el" href="a00043.html#ab7351db4a9af1fbbd0835d9d1e4716fe">AccountManagerInterface::CreateAccount()</a>  . Updating this property will fail on
   externally-stored accounts whose   <a class="el" href="a00041.html#ae1bab8a5affc87fb91f0b81b42da56ba">AccountInterfaceStorageInterface::StorageRestrictions </a>  include
   <code>Cannot_Set_Service</code>.</p>
 <dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="a69c80a9cb0077671630c73c0cfff5c34"></a><!-- doxytag: member="Tp::Client::AccountInterface::setPropertyService" ref="a69c80a9cb0077671630c73c0cfff5c34" args="(QString newValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00301.html">Tp::PendingOperation</a>* Tp::Client::AccountInterface::setPropertyService </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a>&#160;</td>
          <td class="paramname"><em>newValue</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous setter for the remote object property <code>Service</code> of type <code><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a></code>.</p>
 
 <p>Some protocols, like XMPP and SIP, are used by various different
   user-recognised brands, such as <i>Google Talk</i> and <i>Ovi by
   Nokia</i>. On accounts for such services, this property SHOULD be
   set to a string describing the service, which MUST consist only of
   ASCII letters, numbers and hyphen/minus signs, and start with a
   letter (matching the requirements for <tp:type>Protocol</tp:type>).
   For the <tt>jabber</tt> protocol, one of the following service names
   should be used if possible:</p>
 
 <ul>
   <li><tt>google-talk</tt> (for <a href="http://www.google.com/talk/">Google's IM service</a>)</li>
   <li><tt>ovi-chat</tt> (for <a href="http://www.ovi.com/">Ovi</a>'s IM
     service)</li>
   <li><tt>facebook</tt> (for <a href="http://www.facebook.com/sitetour/chat.php">Facebook's IM
     service</a>)</li>
   <li><tt>lj-talk</tt> (for <a href="http://www.livejournal.com/chat/">LiveJournal's IM
     service</a>)</li>
 
 </ul>
 
 <p>The   <a class="el" href="a00038.html#a7b797f4cf85678499338df91d18d8ed6">Icon </a>  property SHOULD be set to a
   corresponding brand-specific icon name, if possible. In the future,
   this property may be used as an index into additional
   service-specific customizations. If this property is the empty string
   (or missing), the service is determined by the protocol name (either
   because this is a single-service protocol like <tt>msn</tt>, or
   because this is just a generic <tt>jabber</tt> or <tt>sip</tt>
   account without specific branding).</p>
 
 <p>This property MAY be set, if appropriate, when calling
     <a class="el" href="a00043.html#ab7351db4a9af1fbbd0835d9d1e4716fe">AccountManagerInterface::CreateAccount()</a>  . Updating this property will fail on
   externally-stored accounts whose   <a class="el" href="a00041.html#ae1bab8a5affc87fb91f0b81b42da56ba">AccountInterfaceStorageInterface::StorageRestrictions </a>  include
   <code>Cannot_Set_Service</code>.</p>
 <dl class="return"><dt><b>Returns:</b></dt><dd>A pending operation which will emit finished when the property has been set. </dd></dl>

</div>
</div>
<a class="anchor" id="a3bba5536ec20e444de1048db449aa981"></a><!-- doxytag: member="Tp::Client::AccountInterface::requestPropertyParameters" ref="a3bba5536ec20e444de1048db449aa981" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00309.html">Tp::PendingVariant</a>* Tp::Client::AccountInterface::requestPropertyParameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property <code>Parameters</code> of type <code>QVariantMap</code>.</p>
 
 <p>A map from connection manager parameter names (as in the
     <a class="el" href="a00153.html">ConnectionManagerInterface</a>  
   interface) to their values. This property includes
   only those parameters that are stored for this account, and SHOULD
   only include those parameters that the user has explicitly set.
 </p>
 <p>This property cannot be altered using
   <code>org.freedesktop.DBus.Properties.Set()</code>; use
     <a class="el" href="a00038.html#a3ba5ad3cfa9a002bb2c66c74104ad532">UpdateParameters()</a>  instead.</p>
 <dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="a05b1a012789347f54c8aa65badd91922"></a><!-- doxytag: member="Tp::Client::AccountInterface::requestPropertyAutomaticPresence" ref="a05b1a012789347f54c8aa65badd91922" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00309.html">Tp::PendingVariant</a>* Tp::Client::AccountInterface::requestPropertyAutomaticPresence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property <code>AutomaticPresence</code> of type <code><a class="el" href="a00364.html">Tp::SimplePresence</a></code>.</p>
 
 <p>The presence status that this account should have if it is brought
   online.</p>
 
 <div class="rationale">
   In ITOS2007 and ITOS2008 this is a global preference, not visible
   on D-Bus (the &quot;default presence&quot;). &quot;Automatic presence&quot; better
   describes when it is used.
 </div>
 
 <p>Setting this property MUST NOT actually change the account's
   status until the next time it is (re)connected for some reason.</p>
 
 <p>The value of this property MUST be one that would be acceptable
   for   <a class="el" href="a00038.html#a38e8810907a6bfcf368ecf2a4d28cba2">RequestedPresence </a>  ,
   with the additional restriction that the
   <tp:type>Connection_Presence_Type</tp:type> MUST NOT be Offline.</p>
 
 <div class="rationale">
   <p>Otherwise, it would not be possible to use this presence to bring
     the account online for a channel request.</p>
 </div>
 <dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="a40662d9b543e60e45a874751e47d2a5e"></a><!-- doxytag: member="Tp::Client::AccountInterface::setPropertyAutomaticPresence" ref="a40662d9b543e60e45a874751e47d2a5e" args="(Tp::SimplePresence newValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00301.html">Tp::PendingOperation</a>* Tp::Client::AccountInterface::setPropertyAutomaticPresence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00364.html">Tp::SimplePresence</a>&#160;</td>
          <td class="paramname"><em>newValue</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous setter for the remote object property <code>AutomaticPresence</code> of type <code><a class="el" href="a00364.html">Tp::SimplePresence</a></code>.</p>
 
 <p>The presence status that this account should have if it is brought
   online.</p>
 
 <div class="rationale">
   In ITOS2007 and ITOS2008 this is a global preference, not visible
   on D-Bus (the &quot;default presence&quot;). &quot;Automatic presence&quot; better
   describes when it is used.
 </div>
 
 <p>Setting this property MUST NOT actually change the account's
   status until the next time it is (re)connected for some reason.</p>
 
 <p>The value of this property MUST be one that would be acceptable
   for   <a class="el" href="a00038.html#a38e8810907a6bfcf368ecf2a4d28cba2">RequestedPresence </a>  ,
   with the additional restriction that the
   <tp:type>Connection_Presence_Type</tp:type> MUST NOT be Offline.</p>
 
 <div class="rationale">
   <p>Otherwise, it would not be possible to use this presence to bring
     the account online for a channel request.</p>
 </div>
 <dl class="return"><dt><b>Returns:</b></dt><dd>A pending operation which will emit finished when the property has been set. </dd></dl>

</div>
</div>
<a class="anchor" id="a1b3df420b6dd256f3246bbe9a283f761"></a><!-- doxytag: member="Tp::Client::AccountInterface::requestPropertyConnectAutomatically" ref="a1b3df420b6dd256f3246bbe9a283f761" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00309.html">Tp::PendingVariant</a>* Tp::Client::AccountInterface::requestPropertyConnectAutomatically </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property <code>ConnectAutomatically</code> of type <code>bool</code>.</p>
<p>If true, the account manager SHOULD attempt to put this account online with the AutomaticPresence whenever possible (in the base <a class="el" href="a00035.html" title="The Account class represents a Telepathy account.">Account</a> interface this is deliberately left vague). If false, it MUST NOT put the account online automatically in response to, for instance, connectivity changes, but SHOULD still put the account online with the AutomaticPresence if requested by the user (for instance, if the user tries to start a conversation using this account).</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="aff2365221bd8ec0cbcac24aa104cef31"></a><!-- doxytag: member="Tp::Client::AccountInterface::setPropertyConnectAutomatically" ref="aff2365221bd8ec0cbcac24aa104cef31" args="(bool newValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00301.html">Tp::PendingOperation</a>* Tp::Client::AccountInterface::setPropertyConnectAutomatically </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>newValue</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous setter for the remote object property <code>ConnectAutomatically</code> of type <code>bool</code>.</p>
<p>If true, the account manager SHOULD attempt to put this account online with the AutomaticPresence whenever possible (in the base <a class="el" href="a00035.html" title="The Account class represents a Telepathy account.">Account</a> interface this is deliberately left vague). If false, it MUST NOT put the account online automatically in response to, for instance, connectivity changes, but SHOULD still put the account online with the AutomaticPresence if requested by the user (for instance, if the user tries to start a conversation using this account).</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pending operation which will emit finished when the property has been set. </dd></dl>

</div>
</div>
<a class="anchor" id="aac5de300678dcb2b3632a06a51954ec0"></a><!-- doxytag: member="Tp::Client::AccountInterface::requestPropertyConnection" ref="aac5de300678dcb2b3632a06a51954ec0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00309.html">Tp::PendingVariant</a>* Tp::Client::AccountInterface::requestPropertyConnection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property <code><a class="el" href="a00127.html" title="The Connection class represents a Telepathy connection.">Connection</a></code> of type <code><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusobjectpath.html">QDBusObjectPath</a></code>.</p>
 
 <p>Either the object path of the   <a class="el" href="a00130.html">ConnectionInterface</a>  to
 this account, or the special value <code>'/'</code> if there is no
 connection.</p>
 
 <p>If this object path is not '/', the Connection's well-known bus
   name can be derived from this object path by removing the first '/'
   and replacing subsequent '/' characters with '.'.</p>
 
 <div class="rationale">
   Object paths aren't nullable, so we can't use an empty string.
 </div>
 <dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="aa96d364028e5a1bf9438552e6d6c6d6c"></a><!-- doxytag: member="Tp::Client::AccountInterface::requestPropertyConnectionStatus" ref="aa96d364028e5a1bf9438552e6d6c6d6c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00309.html">Tp::PendingVariant</a>* Tp::Client::AccountInterface::requestPropertyConnectionStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property <code>ConnectionStatus</code> of type <code>uint</code>.</p>
<p>If the <a class="el" href="a00127.html" title="The Connection class represents a Telepathy connection.">Connection</a> property is non-empty, the status of that connection. If the <a class="el" href="a00127.html" title="The Connection class represents a Telepathy connection.">Connection</a> property is the empty string, this property may either be Disconnected (indicating that the account manager is not attempting to bring it online), or Connecting (indicating that the account manager is attempting to connect). The account manager is expected to set this by observing signals from the <a class="el" href="a00127.html" title="The Connection class represents a Telepathy connection.">Connection</a>. If the AM is doing some sort of backoff/delay on reconnection attempts, the account's status is conceptually "Connecting" even though there is no <a class="el" href="a00127.html" title="The Connection class represents a Telepathy connection.">Connection</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="aac277a5402c90ffc4d7891fecea13ab4"></a><!-- doxytag: member="Tp::Client::AccountInterface::requestPropertyConnectionStatusReason" ref="aac277a5402c90ffc4d7891fecea13ab4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00309.html">Tp::PendingVariant</a>* Tp::Client::AccountInterface::requestPropertyConnectionStatusReason </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property <code>ConnectionStatusReason</code> of type <code>uint</code>.</p>
<p>The reason for the last change to ConnectionStatus. The account manager is expected to set this by observing signals from the <a class="el" href="a00127.html" title="The Connection class represents a Telepathy connection.">Connection</a>. If you weren't watching the <a class="el" href="a00127.html" title="The Connection class represents a Telepathy connection.">Connection</a> at the time it failed, you can't tell why - unless the AM can tell you.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c23434905a5a83069a752620562ac62"></a><!-- doxytag: member="Tp::Client::AccountInterface::requestPropertyConnectionError" ref="a7c23434905a5a83069a752620562ac62" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00309.html">Tp::PendingVariant</a>* Tp::Client::AccountInterface::requestPropertyConnectionError </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property <code>ConnectionError</code> of type <code><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a></code>.</p>
 
 <p>If the last connection to this account failed with an error,
   the D-Bus error name of that error; otherwise, the empty string.
   The account manager is expected to set this by observing the
     <a class="el" href="a00130.html#a7aec7b63ff000b318ded32d9f6f0945e">ConnectionInterface::ConnectionError()</a>  and
     <a class="el" href="a00130.html#a3e844cffb132c2790c1d5e96f49a853d">ConnectionInterface::StatusChanged()</a>  
   signals.</p>
 
 <p>If ConnectionError is received before the connection disconnects,
   its first argument should be used to set this property;
   otherwise, the Reason argument of StatusChanged should be converted
   to a suitable D-Bus error name.</p>
 
 <p>Whenever the Connection connects successfully, this property should
   be reset to the empty string.</p>
 
 <div class="rationale">
   <p>This combines the state-recoverability of
       <a class="el" href="a00038.html#aac277a5402c90ffc4d7891fecea13ab4">ConnectionStatusReason </a>  with the
     extensibility of Connection.ConnectionError.</p>
 </div>
 <dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="a2887994607dffcdc98696a0ce2711fc0"></a><!-- doxytag: member="Tp::Client::AccountInterface::requestPropertyConnectionErrorDetails" ref="a2887994607dffcdc98696a0ce2711fc0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00309.html">Tp::PendingVariant</a>* Tp::Client::AccountInterface::requestPropertyConnectionErrorDetails </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property <code>ConnectionErrorDetails</code> of type <code>QVariantMap</code>.</p>
 
 <p>If the last connection to this account failed with an error,
   a mapping representing any additional information about the last
   disconnection; otherwise, the empty map. The keys and values are
   the same as for the second argument of
     <a class="el" href="a00130.html#a7aec7b63ff000b318ded32d9f6f0945e">ConnectionInterface::ConnectionError()</a>  .</p>
 
 <p>Whenever the Connection connects successfully, this property should
   be reset to the empty map.</p>
 
 <div class="rationale">
   <p>This combines the state-recoverability of
       <a class="el" href="a00038.html#aac277a5402c90ffc4d7891fecea13ab4">ConnectionStatusReason </a>  with the
     extensibility of Connection.ConnectionError.</p>
 </div>
 <dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="a9e6d071253895146d85eb8f315b7eec2"></a><!-- doxytag: member="Tp::Client::AccountInterface::requestPropertyCurrentPresence" ref="a9e6d071253895146d85eb8f315b7eec2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00309.html">Tp::PendingVariant</a>* Tp::Client::AccountInterface::requestPropertyCurrentPresence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property <code>CurrentPresence</code> of type <code><a class="el" href="a00364.html">Tp::SimplePresence</a></code>.</p>
<p>The actual presence. If the connection is not online, the Connection_Presence_Type SHOULD be Connection_Presence_Type_Offline. If the connection is online but does not support the <a class="el" href="a00364.html">SimplePresence</a> interface, the type SHOULD be Connection_Presence_Type_Unset. The account manager is expected to set this by observing signals from the <a class="el" href="a00127.html" title="The Connection class represents a Telepathy connection.">Connection</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="a38e8810907a6bfcf368ecf2a4d28cba2"></a><!-- doxytag: member="Tp::Client::AccountInterface::requestPropertyRequestedPresence" ref="a38e8810907a6bfcf368ecf2a4d28cba2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00309.html">Tp::PendingVariant</a>* Tp::Client::AccountInterface::requestPropertyRequestedPresence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property <code>RequestedPresence</code> of type <code><a class="el" href="a00364.html">Tp::SimplePresence</a></code>.</p>
 
 <p>The requested presence for this account. When this is changed, the
 account manager should attempt to manipulate the connection manager to
 make   <a class="el" href="a00038.html#a9e6d071253895146d85eb8f315b7eec2">CurrentPresence </a>  match
   <a class="el" href="a00038.html#a38e8810907a6bfcf368ecf2a4d28cba2">RequestedPresence </a>  as closely as
   possible. It should not be saved to any sort of persistent
   storage.</p>
 
 <p>When the account manager automatically connects an account,
   it must signal this by setting the RequestedPresence to the same
   thing as the   <a class="el" href="a00038.html#a05b1a012789347f54c8aa65badd91922">AutomaticPresence </a>  .</p>
 
 <p>The <tp:type>Connection_Presence_Type</tp:type> in this property
   MUST NOT be Unset, Unknown or Error.</p>
 
 <div class="rationale">
   <p>Requesting those presence types doesn't make sense.</p>
 </div>
 <dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="adf6efd445e74a91fce805da68acd8d6a"></a><!-- doxytag: member="Tp::Client::AccountInterface::setPropertyRequestedPresence" ref="adf6efd445e74a91fce805da68acd8d6a" args="(Tp::SimplePresence newValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00301.html">Tp::PendingOperation</a>* Tp::Client::AccountInterface::setPropertyRequestedPresence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00364.html">Tp::SimplePresence</a>&#160;</td>
          <td class="paramname"><em>newValue</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous setter for the remote object property <code>RequestedPresence</code> of type <code><a class="el" href="a00364.html">Tp::SimplePresence</a></code>.</p>
 
 <p>The requested presence for this account. When this is changed, the
 account manager should attempt to manipulate the connection manager to
 make   <a class="el" href="a00038.html#a9e6d071253895146d85eb8f315b7eec2">CurrentPresence </a>  match
   <a class="el" href="a00038.html#a38e8810907a6bfcf368ecf2a4d28cba2">RequestedPresence </a>  as closely as
   possible. It should not be saved to any sort of persistent
   storage.</p>
 
 <p>When the account manager automatically connects an account,
   it must signal this by setting the RequestedPresence to the same
   thing as the   <a class="el" href="a00038.html#a05b1a012789347f54c8aa65badd91922">AutomaticPresence </a>  .</p>
 
 <p>The <tp:type>Connection_Presence_Type</tp:type> in this property
   MUST NOT be Unset, Unknown or Error.</p>
 
 <div class="rationale">
   <p>Requesting those presence types doesn't make sense.</p>
 </div>
 <dl class="return"><dt><b>Returns:</b></dt><dd>A pending operation which will emit finished when the property has been set. </dd></dl>

</div>
</div>
<a class="anchor" id="a75c501194be615df752ba7df0c487d25"></a><!-- doxytag: member="Tp::Client::AccountInterface::requestPropertyChangingPresence" ref="a75c501194be615df752ba7df0c487d25" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00309.html">Tp::PendingVariant</a>* Tp::Client::AccountInterface::requestPropertyChangingPresence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property <code>ChangingPresence</code> of type <code>bool</code>.</p>
 
 <p>If true, a change to the presence of this account is
 in progress.</p>
 
 <p>Whenever   <a class="el" href="a00038.html#a38e8810907a6bfcf368ecf2a4d28cba2">RequestedPresence </a>  is set on
 an account that could go online, or whenever an account with a
 non-offline   <a class="el" href="a00038.html#a38e8810907a6bfcf368ecf2a4d28cba2">RequestedPresence </a>  becomes
 able to go online (for instance because
   <a class="el" href="a00038.html#a1ea9fbd2a42882e47ebb70c8fb300845">Enabled </a>  or
   <a class="el" href="a00038.html#ac91ef67bd0fe78f6b55159315a29bb81">Valid </a>  changes to True),
 ChangingPresence MUST change to True, and the two property changes MUST
 be emitted in the same
   <a class="el" href="a00038.html#ab1c040e758a3af7da14fc3f570f24a40">AccountPropertyChanged()</a>  signal, before the
 Set method returns.</p>
 
 <p>When the account manager succeeds or fails in changing the presence,
 or the connection disconnects due to an error, ChangingPresence MUST
 change to False as part of the same
   <a class="el" href="a00038.html#ab1c040e758a3af7da14fc3f570f24a40">AccountPropertyChanged()</a>  signal.</p>
 
 <div class="rationale">
   <p>This allows UIs to indicate that a presence change is in progress
   or has finished, even if the change was initiated by a different
   UI.</p>
 
   <p>For instance, Maemo 5 and Empathy indicate a presence change by
   having the presence indicator alternate between the
     <a class="el" href="a00038.html#a38e8810907a6bfcf368ecf2a4d28cba2">RequestedPresence </a>  
   and the   <a class="el" href="a00038.html#a9e6d071253895146d85eb8f315b7eec2">CurrentPresence </a>  ; they should
   start blinking when ChangingPresence becomes true, and stop when it
   becomes false.</p>
 </div>
 <dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="a9aea7ff6df329438b2a4937686d20219"></a><!-- doxytag: member="Tp::Client::AccountInterface::requestPropertyNormalizedName" ref="a9aea7ff6df329438b2a4937686d20219" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00309.html">Tp::PendingVariant</a>* Tp::Client::AccountInterface::requestPropertyNormalizedName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property <code>NormalizedName</code> of type <code><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a></code>.</p>
 
 <p>The normalized user ID of the local user on this account (i.e. the
   string returned when the   <a class="el" href="a00130.html#a7327cef43f7cfd1fe915727689d10edd">ConnectionInterface::InspectHandles()</a>  
   method is called on the
   result of   <a class="el" href="a00130.html#a584b7c43c4ea3fa60bd540c14abbe432">ConnectionInterface::GetSelfHandle()</a>  
   for an active connection).</p>
 
 <p>It is unspecified whether this user ID is globally unique.</p>
 
 <div class="rationale">
   <p>As currently implemented, IRC user IDs are only unique within
     the same IRCnet. On some saner protocols, the user ID includes a
     DNS name which provides global uniqueness.</p>
 </div>
 
 <p>If this value is not known yet (which will always be the case for
   accounts that have never been online), it will be an empty
   string.</p>
 
 <p>It is possible that this value will change if the connection
   manager's normalization algorithm changes, although this SHOULD
   be avoided.</p>
 
 <div class="rationale">
   <p>It's not always completely clear what normalization algorithm
     should be used; for instance, in Gabble, we currently use JIDs,
     but it would also have been reasonable to use xmpp URIs.</p>
 </div>
 <dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="a4c3d8e27c21236ad39eb3bddac2c46f4"></a><!-- doxytag: member="Tp::Client::AccountInterface::requestPropertyHasBeenOnline" ref="a4c3d8e27c21236ad39eb3bddac2c46f4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00309.html">Tp::PendingVariant</a>* Tp::Client::AccountInterface::requestPropertyHasBeenOnline </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property <code>HasBeenOnline</code> of type <code>bool</code>.</p>
<p>If true, this account has successfully been put online at some point in the past. UIs could apply a policy that the 'account' parameter can only be edited in accounts that have never been online, or that ConnectAutomatically cannot be set on such accounts. The account manager should not enforce such policies, but it can expose enough information to UIs that the UI can decide what to do.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="ab72bdbe9b6f425a75beddc06a1f4b992"></a><!-- doxytag: member="Tp::Client::AccountInterface::requestAllProperties" ref="ab72bdbe9b6f425a75beddc06a1f4b992" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00310.html">Tp::PendingVariantMap</a>* Tp::Client::AccountInterface::requestAllProperties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Request all of the <a class="el" href="a00660.html">DBus</a> properties on the interface.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant map which will emit finished when the properties have been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="aafff9e9364c41883b86e508eae1b6d1e"></a><!-- doxytag: member="Tp::Client::AccountInterface::Remove" ref="aafff9e9364c41883b86e508eae1b6d1e" args="(int timeout=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbuspendingreply.html">QDBusPendingReply</a> Tp::Client::AccountInterface::Remove </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>-1</code></td><td>)</td>
          <td><code> [inline, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Begins a call to the D-Bus method <code>Remove</code> on the remote object.</p>
<p>Delete the account.</p>
<p>Note that <em>timeout</em> is ignored as of now. It will be used once <a href="http://bugreports.qt.nokia.com/browse/QTBUG-11775">http://bugreports.qt.nokia.com/browse/QTBUG-11775</a> is fixed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>The timeout in milliseconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3ba5ad3cfa9a002bb2c66c74104ad532"></a><!-- doxytag: member="Tp::Client::AccountInterface::UpdateParameters" ref="a3ba5ad3cfa9a002bb2c66c74104ad532" args="(const QVariantMap &amp;set, const QStringList &amp;unset, int timeout=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbuspendingreply.html">QDBusPendingReply</a>&lt;<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a>&gt; Tp::Client::AccountInterface::UpdateParameters </td>
          <td>(</td>
          <td class="paramtype">const QVariantMap &amp;&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> &amp;&#160;</td>
          <td class="paramname"><em>unset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Begins a call to the D-Bus method <code>UpdateParameters</code> on the remote object.</p>
 
 <p>Change the value of the   <a class="el" href="a00038.html#a3bba5536ec20e444de1048db449aa981">Parameters </a>  
   property.</p>
 
 <p>If any of the <var>Set</var> parameters
   <tp:type>Conn_Mgr_Param_Flags</tp:type> include
   <code>DBus_Property</code>, the change will be applied immediately to
   the corresponding D-Bus Property on the active
     <a class="el" href="a00038.html#aac5de300678dcb2b3632a06a51954ec0">Connection </a>  , if there is one. If any of
   the <var>Unset</var> parameters
   <tp:type>Conn_Mgr_Param_Flags</tp:type> include both
   <code>DBus_Property</code> and <code>Has_Default</code>, the
   corresponding D-Bus Property on the connection will be set to the
   default value.  Changes to other parameters will not take effect
   until the next time the account is disconnected and reconnected. (If
   parameters are explicitly set to their default value, or are unset
   when previously set to their default value, the account manager MAY
   decide that no reconnection is necessary to make the change take
   effect.)</p>
 
 <div class="rationale">
   <p>In general, reconnecting is a destructive operation that shouldn't
     happen as a side-effect. In particular, migration tools that
     twiddle the settings of all accounts shouldn't cause an automatic
     disconnect and reconnect.</p>
 </div>
 <p>Note that <em>timeout</em> is ignored as of now. It will be used once <a href="http://bugreports.qt.nokia.com/browse/QTBUG-11775">http://bugreports.qt.nokia.com/browse/QTBUG-11775</a> is fixed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>A mapping from parameter names to their values. These parameters should be stored for future use.</td></tr>
    <tr><td class="paramname">unset</td><td>A list of the names of parameters to be removed from the set of stored values, allowing the default values to be used. If the given parameters were not, in fact, stored, or even if they do not exist at all, the account manager MUST accept this without error. </td></tr>
    <tr><td class="paramname">timeout</td><td>The timeout in milliseconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
 
     <p>If all of the updates could be applied to the active
         <a class="el" href="a00038.html#aac5de300678dcb2b3632a06a51954ec0">Connection </a>  (if any),
       the empty list, signifying that no reconnection is required for the
       new parameters to take effect. For example, if the only parameter
       updated is <tt>...Cellular.  <a class="el" href="a00136.html#a557d7738b6669b0ac5a2238c546a989c">ConnectionInterfaceCellularInterface::MessageValidityPeriod </a>  </tt>,
       the new value can be applied immediately to the connection.</p>
     
     <p>Otherwise, a list of the names of parameters with changes that
       will not take effect until the account is reconnected. User
       interfaces that require &quot;instant apply&quot; semantics MAY call
         <a class="el" href="a00038.html#a67dde6a908c5e44c599c6816ab0cf8a8">Reconnect()</a>  in response to receiving a
       non-empty list. For example, if the caller updates both
       <tt>...Anonymity.  <a class="el" href="a00132.html#a86aed866fdf0242e2193992277e28b87">ConnectionInterfaceAnonymityInterface::AnonymityMandatory </a>  </tt>
       and <tt>require-encryption</tt>, the former can be applied to the
       current connection, but the latter needs a reconnect to take
       effect, so this method should return
       <code>[&quot;require-encryption&quot;]</code>.</p>
      
</div>
</div>
<a class="anchor" id="a67dde6a908c5e44c599c6816ab0cf8a8"></a><!-- doxytag: member="Tp::Client::AccountInterface::Reconnect" ref="a67dde6a908c5e44c599c6816ab0cf8a8" args="(int timeout=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbuspendingreply.html">QDBusPendingReply</a> Tp::Client::AccountInterface::Reconnect </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>-1</code></td><td>)</td>
          <td><code> [inline, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Begins a call to the D-Bus method <code>Reconnect</code> on the remote object.</p>
 
 <p>Re-connect this account. If the account is currently disconnected
   and the requested presence is offline, or if the account
   is not   <a class="el" href="a00038.html#a1ea9fbd2a42882e47ebb70c8fb300845">Enabled </a>  or not
     <a class="el" href="a00038.html#ac91ef67bd0fe78f6b55159315a29bb81">Valid </a>  , this does nothing.</p>
 
 <p>If the account is disconnected and the requested presence is not
   offline, this forces an attempt to connect with the requested
   presence immediately.</p>
 
 <p>If the account is connecting or connected, this is equivalent to
   remembering the current value of
     <a class="el" href="a00038.html#a38e8810907a6bfcf368ecf2a4d28cba2">RequestedPresence </a>  , setting its value
   to (OFFLINE, &quot;offline&quot;, &quot;&quot;), waiting for the change to take effect,
   then setting its value to the value that was previously
   remembered.</p>
 
 <div class="rationale">
   <p>Clients desiring &quot;instant apply&quot; semantics for CM parameters MAY
     call this method to achieve that.</p>
 </div>
 
 <p>In particular, if the account's
     <a class="el" href="a00038.html#aac5de300678dcb2b3632a06a51954ec0">Connection </a>  is in the Connecting
   state, calling this method causes the attempt to connect to be
   aborted and re-tried.</p>
 
 <div class="rationale">
   <p>This is necessary to ensure that the new parameters are
     picked up.</p>
 </div>
 <p>Note that <em>timeout</em> is ignored as of now. It will be used once <a href="http://bugreports.qt.nokia.com/browse/QTBUG-11775">http://bugreports.qt.nokia.com/browse/QTBUG-11775</a> is fixed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>The timeout in milliseconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac54562f56877c69c4a3d27ca758cf8fd"></a><!-- doxytag: member="Tp::Client::AccountInterface::Removed" ref="ac54562f56877c69c4a3d27ca758cf8fd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tp::Client::AccountInterface::Removed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Represents the signal <code>Removed</code> on the remote object.</p>
<p>This account has been removed. This is redundant with AccountRemoved, but it's still worth having, to avoid having to bind to AccountManager.AccountRemoved to tell you whether your <a class="el" href="a00035.html" title="The Account class represents a Telepathy account.">Account</a> is valid  ideally, an account-editing UI should only care about a single <a class="el" href="a00035.html" title="The Account class represents a Telepathy account.">Account</a>. </p>

</div>
</div>
<a class="anchor" id="ab1c040e758a3af7da14fc3f570f24a40"></a><!-- doxytag: member="Tp::Client::AccountInterface::AccountPropertyChanged" ref="ab1c040e758a3af7da14fc3f570f24a40" args="(const QVariantMap &amp;properties)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tp::Client::AccountInterface::AccountPropertyChanged </td>
          <td>(</td>
          <td class="paramtype">const QVariantMap &amp;&#160;</td>
          <td class="paramname"><em>properties</em></td><td>)</td>
          <td><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Represents the signal <code>AccountPropertyChanged</code> on the remote object.</p>
<p>The values of one or more properties on this interface (that do not specify that this signal does not apply to them) may have changed. This does not cover properties of other interfaces, which must provide their own change notification if appropriate.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">properties</td><td>A map from property names in this namespace (e.g. Nickname) to values. Properties whose values have not changed SHOULD be omitted, but this need not be done. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3d919b1b4c69abf8f8f221cddf6d9780"></a><!-- doxytag: member="Tp::Client::AccountInterface::invalidate" ref="a3d919b1b4c69abf8f8f221cddf6d9780" args="(Tp::DBusProxy *, const QString &amp;, const QString &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tp::Client::AccountInterface::invalidate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00195.html">Tp::DBusProxy</a> *&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="a00033.html#a79dde56ba44455f47c7c354ada07467a">Tp::AbstractInterface</a>.</p>

</div>
</div>
</div>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td width="30%">Copyright &copy; 2008-2011 Collabora Ltd. and Nokia Corporation</td>
<td width="30%" align="right"><div align="right">Telepathy-Qt4 0.8.0</div></td>
</tr></table></div></address>
</body>
</html>
