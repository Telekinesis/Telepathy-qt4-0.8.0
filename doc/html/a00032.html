<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Tp::AbstractClientObserver Class Reference</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td width="1">&nbsp;&nbsp;</td>
<td class="postheader" valign="center">
<a href="index.html">
<font color="#004faf">Home</font></a>&nbsp;&middot;
<a href="classes.html">
<font color="#004faf">All Classes</font></a>&nbsp;&middot;
<a href="namespaces.html">
<font color="#004faf">All Namespaces</font></a>&nbsp;&middot;
<a href="modules.html">
<font color="#004faf">Modules</font></a>&nbsp;&middot;
<a href="functions.html">
<font color="#004faf">Functions</font></a>&nbsp;&middot;
<a href="files.html">
<font color="#004faf">Files</font></a>
</td>
</tr>
</table>
<!-- Generated by Doxygen 1.7.5 -->
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="a00655.html">Tp</a>      </li>
      <li class="navelem"><a class="el" href="a00032.html">AbstractClientObserver</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">Tp::AbstractClientObserver Class Reference<div class="ingroups"><a class="el" href="a00671.html">Client proxies</a></div></div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Tp::AbstractClientObserver" --><!-- doxytag: inherits="Tp::AbstractClient" -->
<p>The <a class="el" href="a00032.html" title="The AbstractClientObserver class represents a Telepathy observer.">AbstractClientObserver</a> class represents a Telepathy observer.  
 <a href="a00032.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00412_source.html">TelepathyQt4/AbstractClientObserver</a>&gt;</code></p>

<p>Inherits <a class="el" href="a00029.html">Tp::AbstractClient</a>.</p>

<p><a href="a00706.html">List of all members.</a></p>
<h2><a name="nested-classes"></a>
Classes</h2>
<ul>
<li>class <a class="el" href="a00277.html">ObserverInfo</a>
<dl class="el"><dd class="mdescRight">The <a class="el" href="a00277.html" title="The AbstractClientObserver::ObserverInfo class provides a wrapper around the additional info about th...">AbstractClientObserver::ObserverInfo</a> class provides a wrapper around the additional info about the channels passed to <a class="el" href="a00032.html#a8b364b89efd118eb53410e162cd49001">observeChannels()</a>.  <a href="a00277.html#details">More...</a><br/></dl></ul>
<h2><a name="pub-methods"></a>
Public Member Functions</h2>
<ul>
<li>virtual <a class="el" href="a00032.html#af2a98c9910fd0c3c5777ace96389797c">~AbstractClientObserver</a> ()
<li><a class="el" href="a00081.html">ChannelClassSpecList</a> <a class="el" href="a00032.html#a0785ea6763d1e9474451f2f4dbc121a5">observerFilter</a> () const 
<li>bool <a class="el" href="a00032.html#a872a0ff1f6048b76ff71eac4395ecc15">shouldRecover</a> () const 
<li>virtual void <a class="el" href="a00032.html#a8b364b89efd118eb53410e162cd49001">observeChannels</a> (const MethodInvocationContextPtr&lt;&gt; &amp;context, const AccountPtr &amp;account, const ConnectionPtr &amp;connection, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qlist.html">QList</a>&lt; ChannelPtr &gt; &amp;channels, const ChannelDispatchOperationPtr &amp;dispatchOperation, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qlist.html">QList</a>&lt; ChannelRequestPtr &gt; &amp;requestsSatisfied, const <a class="el" href="a00277.html">ObserverInfo</a> &amp;observerInfo)=0
</ul>
<h2><a name="pro-methods"></a>
Protected Member Functions</h2>
<ul>
<li><a class="el" href="a00032.html#a6d64a054dfca03d5329d90d68ff37377">AbstractClientObserver</a> (const <a class="el" href="a00081.html">ChannelClassSpecList</a> &amp;channelFilter, bool shouldRecover=false)
</ul>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="a00032.html" title="The AbstractClientObserver class represents a Telepathy observer.">AbstractClientObserver</a> class represents a Telepathy observer. </p>
<p>Observers are clients that monitor the creation of new channels. This functionality can be used for things like message logging.</p>
<p>Observers should not modify the state of a channel except via user interaction.</p>
<p>Observers must not carry out actions that exactly one process must take responsibility for (e.g. acknowledging text messages, or carrying out the actual file transfer), since arbitrarily many observers can be activated for each channel. The handler is responsible for such tasks.</p>
<p>Handlers may, of course, delegate responsibility for these tasks to other clients (including those run as observers), but this must be done explicitly via a request from the handler to the observer.</p>
<p>Whenever a collection of new channels is signalled, the channel dispatcher will notify all running or activatable observers whose filter indicates that they are interested in some of the channels.</p>
<p>Observers are activated for all channels in which they have registered an interest - incoming, outgoing or automatically created - although of course the filter property can be set to filter specific channels.</p>
<p>To become an observer one should inherit <a class="el" href="a00032.html" title="The AbstractClientObserver class represents a Telepathy observer.">AbstractClientObserver</a> and implement the pure virtual <a class="el" href="a00032.html#a8b364b89efd118eb53410e162cd49001">observeChannels()</a> method. After that the object representing the observer must be registered using <a class="el" href="a00125.html#a18c094053cc83809a167370f7113341b">ClientRegistrar::registerClient()</a>.</p>
<p>When new channels in which the observer has registered an interest are announced, the method <a class="el" href="a00032.html#a8b364b89efd118eb53410e162cd49001">observeChannels()</a> is invoked. All observers are notified simultaneously.</p>
<h2><a class="anchor" id="observer_usage_sec"></a>
Usage</h2>
<h3><a class="anchor" id="observer_create_sec"></a>
Implementing an observer</h3>
<div class="fragment"><pre class="fragment"> <span class="keyword">class </span>MyObserver : <span class="keyword">public</span> <a class="code" href="a00032.html#a6d64a054dfca03d5329d90d68ff37377">AbstractClientObserver</a>
 {
 <span class="keyword">public</span>:
     MyObserver(<span class="keyword">const</span> ChannelClassSpecList &amp;channelFilter);
     ~MyObserver() { }

     <span class="keywordtype">void</span> <a class="code" href="a00032.html#a8b364b89efd118eb53410e162cd49001">observeChannels</a>(<span class="keyword">const</span> MethodInvocationContextPtr&lt;&gt; &amp;context,
             <span class="keyword">const</span> AccountPtr &amp;account,
             <span class="keyword">const</span> ConnectionPtr &amp;connection,
             <span class="keyword">const</span> <a class="codeRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qlist.html">QList&lt;ChannelPtr&gt;</a> &amp;channels,
             <span class="keyword">const</span> ChannelDispatchOperationPtr &amp;dispatchOperation,
             <span class="keyword">const</span> <a class="codeRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qlist.html">QList&lt;ChannelRequestPtr&gt;</a> &amp;requestsSatisfied,
             <span class="keyword">const</span> AbstractClientObserver::ObserverInfo &amp;observerInfo);
 };

 MyObserver::MyObserver(<span class="keyword">const</span> ChannelClassSpecList &amp;channelFilter)
     : <a class="code" href="a00032.html#a6d64a054dfca03d5329d90d68ff37377">AbstractClientObserver</a>(channelFilter)
 {
 }

 <span class="keywordtype">void</span> MyObserver::observeChannels(<span class="keyword">const</span> MethodInvocationContextPtr&lt;&gt; &amp;context,
         <span class="keyword">const</span> AccountPtr &amp;account,
         <span class="keyword">const</span> ConnectionPtr &amp;connection,
         <span class="keyword">const</span> <a class="codeRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qlist.html">QList&lt;ChannelPtr&gt;</a> &amp;channels,
         <span class="keyword">const</span> ChannelDispatchOperationPtr &amp;dispatchOperation,
         <span class="keyword">const</span> <a class="codeRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qlist.html">QList&lt;ChannelRequestPtr&gt;</a> &amp;requestsSatisfied,
         <span class="keyword">const</span> AbstractClientObserver::ObserverInfo &amp;observerInfo)
 {
     <span class="comment">// do something, log messages, ...</span>

     context-&gt;setFinished();
 }
</pre></div><h3><a class="anchor" id="observer_register_sec"></a>
Registering an observer</h3>
<div class="fragment"><pre class="fragment"> ClientRegistrar registrar = <a class="code" href="a00125.html#a82f69f7d62e78d263ac26e5f7b51f523">ClientRegistrar::create</a>();
 AbstractClientPtr observer = AbstractClientPtr::dynamicCast(
         SharedPtr&lt;MyObserver&gt;(<span class="keyword">new</span> MyObserver(
             ChannelClassSpecList() &lt;&lt; <a class="code" href="a00080.html#a8396208afbe06b3b565e301321243adb">ChannelClassSpec::textChat</a>())));
 registrar-&gt;registerClient(observer, <span class="stringliteral">&quot;myobserver&quot;</span>);
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00029.html" title="The AbstractClient class represents a Telepathy client.">AbstractClient</a> </dd></dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af2a98c9910fd0c3c5777ace96389797c"></a><!-- doxytag: member="Tp::AbstractClientObserver::~AbstractClientObserver" ref="af2a98c9910fd0c3c5777ace96389797c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tp::AbstractClientObserver::~AbstractClientObserver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Class destructor. </p>

</div>
</div>
<a class="anchor" id="a6d64a054dfca03d5329d90d68ff37377"></a><!-- doxytag: member="Tp::AbstractClientObserver::AbstractClientObserver" ref="a6d64a054dfca03d5329d90d68ff37377" args="(const ChannelClassSpecList &amp;channelFilter, bool shouldRecover=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tp::AbstractClientObserver::AbstractClientObserver </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00081.html">ChannelClassSpecList</a> &amp;&#160;</td>
          <td class="paramname"><em>channelFilter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldRecover</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a new <a class="el" href="a00032.html" title="The AbstractClientObserver class represents a Telepathy observer.">AbstractClientObserver</a> object.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">channelFilter</td><td>A specification of the channels in which this observer is interested. </td></tr>
    <tr><td class="paramname">shouldRecover</td><td>Whether upon the startup of this observer, <a class="el" href="a00032.html#a8b364b89efd118eb53410e162cd49001">observeChannels()</a> will be called for every already existing channel matching its observerChannelFilter(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a0785ea6763d1e9474451f2f4dbc121a5"></a><!-- doxytag: member="Tp::AbstractClientObserver::observerFilter" ref="a0785ea6763d1e9474451f2f4dbc121a5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00081.html">ChannelClassSpecList</a> Tp::AbstractClientObserver::observerFilter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the property containing a specification of the channels that this channel observer is interested. The <a class="el" href="a00032.html#a8b364b89efd118eb53410e162cd49001">observeChannels()</a> method should be called by the channel dispatcher whenever any of the newly created channels match this description.</p>
<p>See <a href="http://telepathy.freedesktop.org/spec/org.freedesktop.Telepathy.Client.Observer.html#org.freedesktop.Telepathy.Client.Observer.ObserverChannelFilter">the Telepathy specification</a> for documentation about the allowed types and how to define filters.</p>
<p>This property never changes while the observer process owns its client bus name. If an observer wants to add extra channels to its list of interests at runtime, it can register an additional client bus name using <a class="el" href="a00125.html#a18c094053cc83809a167370f7113341b">ClientRegistrar::registerClient()</a>. To remove those filters, it can release the bus name using <a class="el" href="a00125.html#a6bfe24179b1e9d44a6a618a0d346e4a7">ClientRegistrar::unregisterClient()</a>.</p>
<p>The same principle is applied to approvers and handlers.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A specification of the channels that this channel observer is interested as a list of <a class="el" href="a00080.html" title="The ChannelClassSpec class represents a Telepathy channel class.">ChannelClassSpec</a> objects. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00032.html#a8b364b89efd118eb53410e162cd49001">observeChannels()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a872a0ff1f6048b76ff71eac4395ecc15"></a><!-- doxytag: member="Tp::AbstractClientObserver::shouldRecover" ref="a872a0ff1f6048b76ff71eac4395ecc15" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Tp::AbstractClientObserver::shouldRecover </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return whether upon the startup of this observer, <a class="el" href="a00032.html#a8b364b89efd118eb53410e162cd49001">observeChannels()</a> will be called for every already existing channel matching its observerChannelFilter().</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">\c</td><td>true if this observer observerChannels() will be called for every already existing channel matching its observerChannelFilter(), <code>false</code> otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8b364b89efd118eb53410e162cd49001"></a><!-- doxytag: member="Tp::AbstractClientObserver::observeChannels" ref="a8b364b89efd118eb53410e162cd49001" args="(const MethodInvocationContextPtr&lt;&gt; &amp;context, const AccountPtr &amp;account, const ConnectionPtr &amp;connection, const QList&lt; ChannelPtr &gt; &amp;channels, const ChannelDispatchOperationPtr &amp;dispatchOperation, const QList&lt; ChannelRequestPtr &gt; &amp;requestsSatisfied, const ObserverInfo &amp;observerInfo)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tp::AbstractClientObserver::observeChannels </td>
          <td>(</td>
          <td class="paramtype">const MethodInvocationContextPtr&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AccountPtr &amp;&#160;</td>
          <td class="paramname"><em>account</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConnectionPtr &amp;&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qlist.html">QList</a>&lt; ChannelPtr &gt; &amp;&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ChannelDispatchOperationPtr &amp;&#160;</td>
          <td class="paramname"><em>dispatchOperation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qlist.html">QList</a>&lt; ChannelRequestPtr &gt; &amp;&#160;</td>
          <td class="paramname"><em>requestsSatisfied</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00277.html">ObserverInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>observerInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called by the channel dispatcher when channels in which the observer has registered an interest are announced.</p>
<p>If the announced channels contains channels that match the observerChannelFilter(), and some that do not, then only a subset of the channels (those that do match the filter) are passed to this method.</p>
<p>If the channel dispatcher will split up the channels from a single announcement and dispatch them separately (for instance because no installed handler can handle all of them), it will call this method several times.</p>
<p>The observer must not call <a class="el" href="a00269.html#aa3c875e9ae94857386fb612324cfe205">MethodInvocationContext::setFinished()</a> until it is ready for a handler for the channel to run (which may change the channel's state). For instance the received <em>context</em> object should be stored until this method is finished processing and then <a class="el" href="a00269.html#aa3c875e9ae94857386fb612324cfe205">MethodInvocationContext::setFinished()</a> or <a class="el" href="a00269.html#a43e5556ab1aa8c3fb7bfd5a0bd77becf">MethodInvocationContext::setFinishedWithError()</a> should be called on the received <em>context</em> object.</p>
<p>Specialized observers must reimplement this method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>A MethodInvocationContextPtr object that must be used to indicate whether this method finished processing. </td></tr>
    <tr><td class="paramname">account</td><td>The account with which the channels are associated. </td></tr>
    <tr><td class="paramname">connection</td><td>The connection with which the channels are associated. </td></tr>
    <tr><td class="paramname">channels</td><td>The channels to be observed. </td></tr>
    <tr><td class="paramname">dispatchOperation</td><td>The dispatch operation for these channels. The object will be invalid (<a class="el" href="a00195.html#adb39028a597488f81d5f8bacfe822886">DBusProxy::isValid()</a> will be false) if there is no dispatch operation in place (because the channels were requested, not incoming). If the Observer calls <a class="el" href="a00084.html#abe3cc768fce132036939f63384fe7c82">ChannelDispatchOperation::claim()</a> or <a class="el" href="a00084.html#a6110ece4fc4e28a5a8fc071fb1871f9d">ChannelDispatchOperation::handleWith()</a> on this object, it must be careful to avoid deadlock, since these methods cannot return until the observer has returned from <a class="el" href="a00032.html#a8b364b89efd118eb53410e162cd49001">observeChannels()</a>. </td></tr>
    <tr><td class="paramname">requestsSatisfied</td><td>The requests satisfied by these channels. </td></tr>
    <tr><td class="paramname">observerInfo</td><td>Additional information about these channels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td width="30%">Copyright &copy; 2008-2011 Collabora Ltd. and Nokia Corporation</td>
<td width="30%" align="right"><div align="right">Telepathy-Qt4 0.8.0</div></td>
</tr></table></div></address>
</body>
</html>
