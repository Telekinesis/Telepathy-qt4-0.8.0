<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Tp::ConnectionLowlevel Class Reference</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td width="1">&nbsp;&nbsp;</td>
<td class="postheader" valign="center">
<a href="index.html">
<font color="#004faf">Home</font></a>&nbsp;&middot;
<a href="classes.html">
<font color="#004faf">All Classes</font></a>&nbsp;&middot;
<a href="namespaces.html">
<font color="#004faf">All Namespaces</font></a>&nbsp;&middot;
<a href="modules.html">
<font color="#004faf">Modules</font></a>&nbsp;&middot;
<a href="functions.html">
<font color="#004faf">Functions</font></a>&nbsp;&middot;
<a href="files.html">
<font color="#004faf">Files</font></a>
</td>
</tr>
</table>
<!-- Generated by Doxygen 1.7.5 -->
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="a00655.html">Tp</a>      </li>
      <li class="navelem"><a class="el" href="a00151.html">ConnectionLowlevel</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">Tp::ConnectionLowlevel Class Reference<div class="ingroups"><a class="el" href="a00673.html">Connection proxies</a></div></div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Tp::ConnectionLowlevel" --><!-- doxytag: inherits="QObject,Tp::RefCounted" -->
<p>The <a class="el" href="a00151.html" title="The ConnectionLowlevel class extends Connection with support to low-level features.">ConnectionLowlevel</a> class extends <a class="el" href="a00127.html" title="The Connection class represents a Telepathy connection.">Connection</a> with support to low-level features.  
 <a href="a00151.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00486_source.html">TelepathyQt4/ConnectionLowlevel</a>&gt;</code></p>

<p>Inherits <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qobject.html">QObject</a>, and <a class="el" href="a00336.html">Tp::RefCounted</a>.</p>

<p><a href="a00733.html">List of all members.</a></p>
<h2><a name="pub-methods"></a>
Public Member Functions</h2>
<ul>
<li><a class="el" href="a00151.html#aec70ebc6f61d39f2f6ce9a7251e545e1">~ConnectionLowlevel</a> ()
<li>bool <a class="el" href="a00151.html#a989c8d7ecb790f008351c0be8801986f">isValid</a> () const 
<li>ConnectionPtr <a class="el" href="a00151.html#a296be91116fa075ed800ab271d7c41bc">connection</a> () const 
<li><a class="el" href="a00302.html">PendingReady</a> * <a class="el" href="a00151.html#adad3f0e46e1c3c4c98544bb7d340480d">requestConnect</a> (const <a class="el" href="a00206.html">Features</a> &amp;requestedFeatures=<a class="el" href="a00206.html">Features</a>())
<li><a class="el" href="a00301.html">PendingOperation</a> * <a class="el" href="a00151.html#a755798967e4cdf6da1289da28862b179">requestDisconnect</a> ()
<li><a class="el" href="a00366.html">SimpleStatusSpecMap</a> <a class="el" href="a00151.html#aed9fc8c25a465d3838355850e141ef00">allowedPresenceStatuses</a> () const 
<li>uint <a class="el" href="a00151.html#a38ea995a0439b2d796bdfc7b0202e3f9">maxPresenceStatusMessageLength</a> () const 
<li><a class="el" href="a00301.html">PendingOperation</a> * <a class="el" href="a00151.html#a75ac25bfa3bdbf9f012ff223406d8db7">setSelfPresence</a> (const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;status, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;statusMessage)
<li><a class="el" href="a00292.html">PendingChannel</a> * <a class="el" href="a00151.html#a7b12503cbb302b81e6d66bde16ce3e22">createChannel</a> (const QVariantMap &amp;request)
<li><a class="el" href="a00292.html">PendingChannel</a> * <a class="el" href="a00151.html#aa2735d19e297d0840854a2a13982ae4e">createChannel</a> (const QVariantMap &amp;request, int timeout)
<li><a class="el" href="a00292.html">PendingChannel</a> * <a class="el" href="a00151.html#a206bf1c04cf460b00ce96527632cc3b7">ensureChannel</a> (const QVariantMap &amp;request)
<li><a class="el" href="a00292.html">PendingChannel</a> * <a class="el" href="a00151.html#a81921413027017073265d874e2a216ee">ensureChannel</a> (const QVariantMap &amp;request, int timeout)
<li><a class="el" href="a00300.html">PendingHandles</a> * <a class="el" href="a00151.html#a78ab30b0f022b5624eb74bfa63984e6b">requestHandles</a> (<a class="el" href="a00681.html#ga36fa367f622d8b98416393b3fe4c89d2">HandleType</a> handleType, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> &amp;names)
<li><a class="el" href="a00300.html">PendingHandles</a> * <a class="el" href="a00151.html#a215e173f60e1c5c3cb72f1a81aaac152">referenceHandles</a> (<a class="el" href="a00681.html#ga36fa367f622d8b98416393b3fe4c89d2">HandleType</a> handleType, const <a class="el" href="a00397.html">UIntList</a> &amp;handles)
<li><a class="el" href="a00296.html">PendingContactAttributes</a> * <a class="el" href="a00151.html#abe631c36b5c3c3c2f5f47da299dd9b8f">contactAttributes</a> (const <a class="el" href="a00397.html">UIntList</a> &amp;handles, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> &amp;interfaces, bool reference=true)
<li><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> <a class="el" href="a00151.html#a5c29fee7f683b77cc9e547572cfef027">contactAttributeInterfaces</a> () const 
<li>void <a class="el" href="a00151.html#a98c37ffb06db1147ece617022162417e">injectContactIds</a> (const <a class="el" href="a00217.html">HandleIdentifierMap</a> &amp;contactIds)
<li>void <a class="el" href="a00151.html#af6bb69a40fcd7570927d5e0d0af1f7bb">injectContactId</a> (uint handle, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;contactId)
</ul>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="a00151.html" title="The ConnectionLowlevel class extends Connection with support to low-level features.">ConnectionLowlevel</a> class extends <a class="el" href="a00127.html" title="The Connection class represents a Telepathy connection.">Connection</a> with support to low-level features. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aec70ebc6f61d39f2f6ce9a7251e545e1"></a><!-- doxytag: member="Tp::ConnectionLowlevel::~ConnectionLowlevel" ref="aec70ebc6f61d39f2f6ce9a7251e545e1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tp::ConnectionLowlevel::~ConnectionLowlevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a989c8d7ecb790f008351c0be8801986f"></a><!-- doxytag: member="Tp::ConnectionLowlevel::isValid" ref="a989c8d7ecb790f008351c0be8801986f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Tp::ConnectionLowlevel::isValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a296be91116fa075ed800ab271d7c41bc"></a><!-- doxytag: member="Tp::ConnectionLowlevel::connection" ref="a296be91116fa075ed800ab271d7c41bc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConnectionPtr Tp::ConnectionLowlevel::connection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adad3f0e46e1c3c4c98544bb7d340480d"></a><!-- doxytag: member="Tp::ConnectionLowlevel::requestConnect" ref="adad3f0e46e1c3c4c98544bb7d340480d" args="(const Features &amp;requestedFeatures=Features())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00302.html">PendingReady</a> * Tp::ConnectionLowlevel::requestConnect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00206.html">Features</a> &amp;&#160;</td>
          <td class="paramname"><em>requestedFeatures</em> = <code><a class="el" href="a00206.html">Features</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Start an asynchronous request that the connection be connected.</p>
<p>When using a full-fledged Telepathy setup with an <a class="el" href="a00035.html" title="The Account class represents a Telepathy account.">Account</a> Manager service, the <a class="el" href="a00035.html" title="The Account class represents a Telepathy account.">Account</a> methods <a class="el" href="a00035.html#afd8463718f9643b2b1f32cb45bb6a776">Account::setRequestedPresence()</a> and <a class="el" href="a00035.html#acf58d85dd564cf237609dd5b2097784f">Account::reconnect()</a> must be used instead.</p>
<p>The returned <a class="el" href="a00301.html" title="The PendingOperation class is a base class for pending asynchronous operations.">PendingOperation</a> will finish successfully when the connection has reached ConnectionStatusConnected and the requested <em>features</em> are all ready, or finish with an error if a fatal error occurs during that process.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">requestedFeatures</td><td>The features which should be enabled </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="a00302.html" title="The PendingReady class represents the features requested and the reply to a request for an object to ...">PendingReady</a> which will emit <a class="el" href="a00301.html#addbb8c4462019ffdf19095a31da0cc7a">PendingReady::finished</a> when the <a class="el" href="a00127.html" title="The Connection class represents a Telepathy connection.">Connection</a> has reached <a class="el" href="a00655.html#ga601f90d95125a95ed0ff9a546fb1363fa6af1d5f41051b70b5c14bd19c4174d17">ConnectionStatusConnected</a>, and initial setup for basic functionality, plus the given features, has succeeded or failed. </dd></dl>

</div>
</div>
<a class="anchor" id="a755798967e4cdf6da1289da28862b179"></a><!-- doxytag: member="Tp::ConnectionLowlevel::requestDisconnect" ref="a755798967e4cdf6da1289da28862b179" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00301.html">PendingOperation</a> * Tp::ConnectionLowlevel::requestDisconnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Start an asynchronous request that the connection be disconnected. The returned <a class="el" href="a00301.html" title="The PendingOperation class is a base class for pending asynchronous operations.">PendingOperation</a> object will signal the success or failure of this request; under normal circumstances, it can be expected to succeed.</p>
<p>When using a full-fledged Telepathy setup with an <a class="el" href="a00035.html" title="The Account class represents a Telepathy account.">Account</a> Manager service, <a class="el" href="a00035.html#afd8463718f9643b2b1f32cb45bb6a776">Account::setRequestedPresence()</a> with <a class="el" href="a00312.html#a40f43f74e4393a1f09cc825a3749127a">Presence::offline()</a> as an argument should generally be used instead.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="a00301.html" title="The PendingOperation class is a base class for pending asynchronous operations.">PendingOperation</a> which will emit <a class="el" href="a00301.html#addbb8c4462019ffdf19095a31da0cc7a">PendingOperation::finished</a> when the request has been made. </dd></dl>

</div>
</div>
<a class="anchor" id="aed9fc8c25a465d3838355850e141ef00"></a><!-- doxytag: member="Tp::ConnectionLowlevel::allowedPresenceStatuses" ref="aed9fc8c25a465d3838355850e141ef00" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00366.html">SimpleStatusSpecMap</a> Tp::ConnectionLowlevel::allowedPresenceStatuses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a dictionary of presence statuses valid for use in this connection.</p>
<p>The value may have changed arbitrarily during the time the <a class="el" href="a00127.html" title="The Connection class represents a Telepathy connection.">Connection</a> spends in status ConnectionStatusConnecting, again staying fixed for the entire time in ConnectionStatusConnected.</p>
<p>This method requires <a class="el" href="a00127.html#af832a6ba64e4811a2ff364c755493afb">Connection::FeatureSimplePresence</a> to be ready.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The allowed statuses as a map from string identifiers to <a class="el" href="a00365.html">SimpleStatusSpec</a> objects. </dd></dl>

</div>
</div>
<a class="anchor" id="a38ea995a0439b2d796bdfc7b0202e3f9"></a><!-- doxytag: member="Tp::ConnectionLowlevel::maxPresenceStatusMessageLength" ref="a38ea995a0439b2d796bdfc7b0202e3f9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint Tp::ConnectionLowlevel::maxPresenceStatusMessageLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the maximum length for a presence status message.</p>
<p>The value may have changed arbitrarily during the time the <a class="el" href="a00127.html" title="The Connection class represents a Telepathy connection.">Connection</a> spends in status ConnectionStatusConnecting, again staying fixed for the entire time in ConnectionStatusConnected.</p>
<p>This method requires <a class="el" href="a00127.html#af832a6ba64e4811a2ff364c755493afb">Connection::FeatureSimplePresence</a> to be ready.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The maximum length, or 0 if there is no limit. </dd></dl>

</div>
</div>
<a class="anchor" id="a75ac25bfa3bdbf9f012ff223406d8db7"></a><!-- doxytag: member="Tp::ConnectionLowlevel::setSelfPresence" ref="a75ac25bfa3bdbf9f012ff223406d8db7" args="(const QString &amp;status, const QString &amp;statusMessage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00301.html">PendingOperation</a> * Tp::ConnectionLowlevel::setSelfPresence </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>statusMessage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the self presence status.</p>
<p>This should generally only be called by an <a class="el" href="a00035.html" title="The Account class represents a Telepathy account.">Account</a> Manager. In typical usage, <a class="el" href="a00035.html#afd8463718f9643b2b1f32cb45bb6a776">Account::setRequestedPresence()</a> should be used instead.</p>
<p><em>status</em> must be one of the allowed statuses returned by <a class="el" href="a00151.html#aed9fc8c25a465d3838355850e141ef00">allowedPresenceStatuses()</a>.</p>
<p>Note that clients SHOULD set the status message for the local user to the empty string, unless the user has actually provided a specific message (i.e. one that conveys more information than the ConnectionStatus).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>The desired status. </td></tr>
    <tr><td class="paramname">statusMessage</td><td>The desired status message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="a00301.html" title="The PendingOperation class is a base class for pending asynchronous operations.">PendingOperation</a> which will emit <a class="el" href="a00301.html#addbb8c4462019ffdf19095a31da0cc7a">PendingOperation::finished</a> when the call has finished. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00151.html#aed9fc8c25a465d3838355850e141ef00">allowedPresenceStatuses()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7b12503cbb302b81e6d66bde16ce3e22"></a><!-- doxytag: member="Tp::ConnectionLowlevel::createChannel" ref="a7b12503cbb302b81e6d66bde16ce3e22" args="(const QVariantMap &amp;request)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00292.html">PendingChannel</a> * Tp::ConnectionLowlevel::createChannel </td>
          <td>(</td>
          <td class="paramtype">const QVariantMap &amp;&#160;</td>
          <td class="paramname"><em>request</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Same as <code>createChannel</code>(request, -1) </p>

</div>
</div>
<a class="anchor" id="aa2735d19e297d0840854a2a13982ae4e"></a><!-- doxytag: member="Tp::ConnectionLowlevel::createChannel" ref="aa2735d19e297d0840854a2a13982ae4e" args="(const QVariantMap &amp;request, int timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00292.html">PendingChannel</a> * Tp::ConnectionLowlevel::createChannel </td>
          <td>(</td>
          <td class="paramtype">const QVariantMap &amp;&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronously creates a channel satisfying the given request.</p>
<p>In typical usage, only the <a class="el" href="a00077.html" title="The Channel class represents a Telepathy channel.">Channel</a> Dispatcher should call this. Ordinary applications should use the <a class="el" href="a00035.html#a3e66f0bd5bdd3ab38fcd908f2d4db50a">Account::createChannel()</a> family of methods (which invoke the <a class="el" href="a00077.html" title="The Channel class represents a Telepathy channel.">Channel</a> Dispatcher's services).</p>
<p>The request MUST contain the following keys: org.freedesktop.Telepathy.Channel.ChannelType org.freedesktop.Telepathy.Channel.TargetHandleType</p>
<p>Upon completion, the reply to the request can be retrieved through the returned <a class="el" href="a00292.html" title="The PendingChannel class represents the parameters of and the reply to an asynchronous channel reques...">PendingChannel</a> object. The object also provides access to the parameters with which the call was made and a signal to connect to get notification of the request finishing processing. See the documentation for that class for more info.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td>A dictionary containing the desirable properties. </td></tr>
    <tr><td class="paramname">timeout</td><td>The D-Bus timeout in milliseconds used for the method call. If timeout is -1, a default implementation-defined value that is suitable for inter-process communications (generally, 25 seconds) will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="a00292.html" title="The PendingChannel class represents the parameters of and the reply to an asynchronous channel reques...">PendingChannel</a> which will emit <a class="el" href="a00301.html#addbb8c4462019ffdf19095a31da0cc7a">PendingChannel::finished</a> when the channel has been created, or an error occurred. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00292.html" title="The PendingChannel class represents the parameters of and the reply to an asynchronous channel reques...">PendingChannel</a>, <a class="el" href="a00151.html#a206bf1c04cf460b00ce96527632cc3b7">ensureChannel()</a>, <a class="el" href="a00035.html#a3e66f0bd5bdd3ab38fcd908f2d4db50a">Account::createChannel()</a>, <a class="el" href="a00035.html#aed5d16035a1c442e93a2fae72b850857">Account::createAndHandleChannel()</a>, <a class="el" href="a00035.html#ac3eb946da217e1ea462fbe8c7b32d0b3">Account::ensureChannel()</a>, <a class="el" href="a00035.html#aee4ba1ddaf5b965e05803554e4d6ca02">Account::ensureAndHandleChannel()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a206bf1c04cf460b00ce96527632cc3b7"></a><!-- doxytag: member="Tp::ConnectionLowlevel::ensureChannel" ref="a206bf1c04cf460b00ce96527632cc3b7" args="(const QVariantMap &amp;request)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00292.html">PendingChannel</a> * Tp::ConnectionLowlevel::ensureChannel </td>
          <td>(</td>
          <td class="paramtype">const QVariantMap &amp;&#160;</td>
          <td class="paramname"><em>request</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Same as <code>ensureChannel</code>(request, -1) </p>

</div>
</div>
<a class="anchor" id="a81921413027017073265d874e2a216ee"></a><!-- doxytag: member="Tp::ConnectionLowlevel::ensureChannel" ref="a81921413027017073265d874e2a216ee" args="(const QVariantMap &amp;request, int timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00292.html">PendingChannel</a> * Tp::ConnectionLowlevel::ensureChannel </td>
          <td>(</td>
          <td class="paramtype">const QVariantMap &amp;&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronously ensures a channel exists satisfying the given request.</p>
<p>In typical usage, only the <a class="el" href="a00077.html" title="The Channel class represents a Telepathy channel.">Channel</a> Dispatcher should call this. Ordinary applications should use the <a class="el" href="a00035.html#ac3eb946da217e1ea462fbe8c7b32d0b3">Account::ensureChannel()</a> family of methods (which invoke the <a class="el" href="a00077.html" title="The Channel class represents a Telepathy channel.">Channel</a> Dispatcher's services).</p>
<p>The request MUST contain the following keys: org.freedesktop.Telepathy.Channel.ChannelType org.freedesktop.Telepathy.Channel.TargetHandleType</p>
<p>Upon completion, the reply to the request can be retrieved through the returned <a class="el" href="a00292.html" title="The PendingChannel class represents the parameters of and the reply to an asynchronous channel reques...">PendingChannel</a> object. The object also provides access to the parameters with which the call was made and a signal to connect to get notification of the request finishing processing. See the documentation for that class for more info.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td>A dictionary containing the desirable properties. </td></tr>
    <tr><td class="paramname">timeout</td><td>The D-Bus timeout in milliseconds used for the method call. If timeout is -1, a default implementation-defined value that is suitable for inter-process communications (generally, 25 seconds) will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="a00292.html" title="The PendingChannel class represents the parameters of and the reply to an asynchronous channel reques...">PendingChannel</a> which will emit <a class="el" href="a00301.html#addbb8c4462019ffdf19095a31da0cc7a">PendingChannel::finished</a> when the channel is ensured to exist, or an error occurred. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00292.html" title="The PendingChannel class represents the parameters of and the reply to an asynchronous channel reques...">PendingChannel</a>, <a class="el" href="a00151.html#a7b12503cbb302b81e6d66bde16ce3e22">createChannel()</a>, <a class="el" href="a00035.html#a3e66f0bd5bdd3ab38fcd908f2d4db50a">Account::createChannel()</a>, <a class="el" href="a00035.html#aed5d16035a1c442e93a2fae72b850857">Account::createAndHandleChannel()</a>, <a class="el" href="a00035.html#ac3eb946da217e1ea462fbe8c7b32d0b3">Account::ensureChannel()</a>, <a class="el" href="a00035.html#aee4ba1ddaf5b965e05803554e4d6ca02">Account::ensureAndHandleChannel()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a78ab30b0f022b5624eb74bfa63984e6b"></a><!-- doxytag: member="Tp::ConnectionLowlevel::requestHandles" ref="a78ab30b0f022b5624eb74bfa63984e6b" args="(HandleType handleType, const QStringList &amp;names)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00300.html">PendingHandles</a> * Tp::ConnectionLowlevel::requestHandles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00681.html#ga36fa367f622d8b98416393b3fe4c89d2">HandleType</a>&#160;</td>
          <td class="paramname"><em>handleType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> &amp;&#160;</td>
          <td class="paramname"><em>names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Request handles of the given type for the given entities (contacts, rooms, lists, etc.).</p>
<p>Typically one doesn't need to request and use handles directly; instead, string identifiers and/or <a class="el" href="a00175.html" title="The Contact class represents a Telepathy contact.">Contact</a> objects are used in most APIs. File a bug for APIs in which there is no alternative to using handles. In particular however using low-level DBus interfaces for which there is no corresponding high-level (or one is implementing that abstraction) functionality does and will always require using bare handles.</p>
<p>Upon completion, the reply to the request can be retrieved through the returned <a class="el" href="a00300.html" title="The PendingHandles class represents the parameters of and the reply to an asynchronous handle request...">PendingHandles</a> object. The object also provides access to the parameters with which the call was made and a signal to connect to to get notification of the request finishing processing. See the documentation for that class for more info.</p>
<p>The returned <a class="el" href="a00300.html" title="The PendingHandles class represents the parameters of and the reply to an asynchronous handle request...">PendingHandles</a> object should be freed using its <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qobject.html#deleteLater">QObject::deleteLater()</a> method after it is no longer used. However, all <a class="el" href="a00300.html" title="The PendingHandles class represents the parameters of and the reply to an asynchronous handle request...">PendingHandles</a> objects resulting from requests to a particular <a class="el" href="a00127.html" title="The Connection class represents a Telepathy connection.">Connection</a> will be freed when the <a class="el" href="a00127.html" title="The Connection class represents a Telepathy connection.">Connection</a> itself is freed. Conversely, this means that the <a class="el" href="a00300.html" title="The PendingHandles class represents the parameters of and the reply to an asynchronous handle request...">PendingHandles</a> object should not be used after the <a class="el" href="a00127.html" title="The Connection class represents a Telepathy connection.">Connection</a> is destroyed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handleType</td><td>Type for the handles to request, as specified in <a class="el" href="a00681.html#ga36fa367f622d8b98416393b3fe4c89d2">HandleType</a>. </td></tr>
    <tr><td class="paramname">names</td><td>Names of the entities to request handles for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="a00300.html" title="The PendingHandles class represents the parameters of and the reply to an asynchronous handle request...">PendingHandles</a> which will emit <a class="el" href="a00301.html#addbb8c4462019ffdf19095a31da0cc7a">PendingHandles::finished</a> when the handles have been requested, or an error occurred. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00300.html" title="The PendingHandles class represents the parameters of and the reply to an asynchronous handle request...">PendingHandles</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a215e173f60e1c5c3cb72f1a81aaac152"></a><!-- doxytag: member="Tp::ConnectionLowlevel::referenceHandles" ref="a215e173f60e1c5c3cb72f1a81aaac152" args="(HandleType handleType, const UIntList &amp;handles)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00300.html">PendingHandles</a> * Tp::ConnectionLowlevel::referenceHandles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00681.html#ga36fa367f622d8b98416393b3fe4c89d2">HandleType</a>&#160;</td>
          <td class="paramname"><em>handleType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00397.html">UIntList</a> &amp;&#160;</td>
          <td class="paramname"><em>handles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Request a reference to the given handles. Handles not explicitly requested (via <a class="el" href="a00151.html#a78ab30b0f022b5624eb74bfa63984e6b">requestHandles()</a>) but eg. observed in a signal need to be referenced to guarantee them staying valid.</p>
<p>Typically one doesn't need to reference and use handles directly; instead, string identifiers and/or <a class="el" href="a00175.html" title="The Contact class represents a Telepathy contact.">Contact</a> objects are used in most APIs. File a bug for APIs in which there is no alternative to using handles. In particular however using low-level DBus interfaces for which there is no corresponding high-level (or one is implementing that abstraction) functionality does and will always require using bare handles.</p>
<p>Upon completion, the reply to the operation can be retrieved through the returned <a class="el" href="a00300.html" title="The PendingHandles class represents the parameters of and the reply to an asynchronous handle request...">PendingHandles</a> object. The object also provides access to the parameters with which the call was made and a signal to connect to to get notification of the request finishing processing. See the documentation for that class for more info.</p>
<p>The returned <a class="el" href="a00300.html" title="The PendingHandles class represents the parameters of and the reply to an asynchronous handle request...">PendingHandles</a> object should be freed using its <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qobject.html#deleteLater">QObject::deleteLater()</a> method after it is no longer used. However, all <a class="el" href="a00300.html" title="The PendingHandles class represents the parameters of and the reply to an asynchronous handle request...">PendingHandles</a> objects resulting from requests to a particular <a class="el" href="a00127.html" title="The Connection class represents a Telepathy connection.">Connection</a> will be freed when the <a class="el" href="a00127.html" title="The Connection class represents a Telepathy connection.">Connection</a> itself is freed. Conversely, this means that the <a class="el" href="a00300.html" title="The PendingHandles class represents the parameters of and the reply to an asynchronous handle request...">PendingHandles</a> object should not be used after the <a class="el" href="a00127.html" title="The Connection class represents a Telepathy connection.">Connection</a> is destroyed.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00300.html" title="The PendingHandles class represents the parameters of and the reply to an asynchronous handle request...">PendingHandles</a></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handleType</td><td>Type of the handles given, as specified in <a class="el" href="a00681.html#ga36fa367f622d8b98416393b3fe4c89d2">HandleType</a>. </td></tr>
    <tr><td class="paramname">handles</td><td>Handles to request a reference to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="a00300.html" title="The PendingHandles class represents the parameters of and the reply to an asynchronous handle request...">PendingHandles</a> which will emit <a class="el" href="a00301.html#addbb8c4462019ffdf19095a31da0cc7a">PendingHandles::finished</a> when the handles have been referenced, or an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="abe631c36b5c3c3c2f5f47da299dd9b8f"></a><!-- doxytag: member="Tp::ConnectionLowlevel::contactAttributes" ref="abe631c36b5c3c3c2f5f47da299dd9b8f" args="(const UIntList &amp;handles, const QStringList &amp;interfaces, bool reference=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00296.html">PendingContactAttributes</a> * Tp::ConnectionLowlevel::contactAttributes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00397.html">UIntList</a> &amp;&#160;</td>
          <td class="paramname"><em>handles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> &amp;&#160;</td>
          <td class="paramname"><em>interfaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reference</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Requests attributes for contacts. Optionally, the handles of the contacts will be referenced automatically. Essentially, this method wraps ConnectionInterfaceContactsInterface::GetContactAttributes(), integrating it with the rest of the handle-referencing machinery.</p>
<p>This is very low-level API the Contact/ContactManager API provides a higher level of abstraction for the same functionality.</p>
<p>Upon completion, the reply to the request can be retrieved through the returned <a class="el" href="a00296.html" title="The PendingContactAttributes class represents the parameters of and the reply to an asynchronous requ...">PendingContactAttributes</a> object. The object also provides access to the parameters with which the call was made and a signal to connect to to get notification of the request finishing processing. See the documentation for that class for more info.</p>
<p>If the remote object doesn't support the Contacts interface (as signified by the list returned by interfaces() not containing <a class="el" href="a00682.html#ga6402e23148c567ef9ff8d3b55c75ddc1">TP_QT4_IFACE_CONNECTION_INTERFACE_CONTACTS</a>), the returned <a class="el" href="a00296.html" title="The PendingContactAttributes class represents the parameters of and the reply to an asynchronous requ...">PendingContactAttributes</a> instance will fail instantly with the error <a class="el" href="a00683.html#ga6d4515ee975d11b31ab0a94be1ea698d">TP_QT4_ERROR_NOT_IMPLEMENTED</a>.</p>
<p>Similarly, if the connection isn't both connected and ready (<code>status() == ConnectionStatusConnected &amp;&amp; isReady(Connection::FeatureCore)</code>), the returned <a class="el" href="a00296.html" title="The PendingContactAttributes class represents the parameters of and the reply to an asynchronous requ...">PendingContactAttributes</a> instance will fail instantly with the error <a class="el" href="a00683.html#gaaec8073a9ddc5d967bc66a2d9fe54925">TP_QT4_ERROR_NOT_AVAILABLE</a>.</p>
<p>This method requires <a class="el" href="a00127.html#abc270e079265fcbec7e422d002523298">Connection::FeatureCore</a> to be ready.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00296.html" title="The PendingContactAttributes class represents the parameters of and the reply to an asynchronous requ...">PendingContactAttributes</a></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handles</td><td>A list of handles of type HandleTypeContact </td></tr>
    <tr><td class="paramname">interfaces</td><td>D-Bus interfaces for which the client requires information </td></tr>
    <tr><td class="paramname">reference</td><td>Whether the handles should additionally be referenced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="a00296.html" title="The PendingContactAttributes class represents the parameters of and the reply to an asynchronous requ...">PendingContactAttributes</a> which will emit PendingContactAttributes::fininshed when the contact attributes have been retrieved, or an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a5c29fee7f683b77cc9e547572cfef027"></a><!-- doxytag: member="Tp::ConnectionLowlevel::contactAttributeInterfaces" ref="a5c29fee7f683b77cc9e547572cfef027" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> Tp::ConnectionLowlevel::contactAttributeInterfaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a98c37ffb06db1147ece617022162417e"></a><!-- doxytag: member="Tp::ConnectionLowlevel::injectContactIds" ref="a98c37ffb06db1147ece617022162417e" args="(const HandleIdentifierMap &amp;contactIds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tp::ConnectionLowlevel::injectContactIds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00217.html">HandleIdentifierMap</a> &amp;&#160;</td>
          <td class="paramname"><em>contactIds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af6bb69a40fcd7570927d5e0d0af1f7bb"></a><!-- doxytag: member="Tp::ConnectionLowlevel::injectContactId" ref="af6bb69a40fcd7570927d5e0d0af1f7bb" args="(uint handle, const QString &amp;contactId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tp::ConnectionLowlevel::injectContactId </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>contactId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td width="30%">Copyright &copy; 2008-2011 Collabora Ltd. and Nokia Corporation</td>
<td width="30%" align="right"><div align="right">Telepathy-Qt4 0.8.0</div></td>
</tr></table></div></address>
</body>
</html>
