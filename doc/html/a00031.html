<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Tp::AbstractClientHandler Class Reference</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td width="1">&nbsp;&nbsp;</td>
<td class="postheader" valign="center">
<a href="index.html">
<font color="#004faf">Home</font></a>&nbsp;&middot;
<a href="classes.html">
<font color="#004faf">All Classes</font></a>&nbsp;&middot;
<a href="namespaces.html">
<font color="#004faf">All Namespaces</font></a>&nbsp;&middot;
<a href="modules.html">
<font color="#004faf">Modules</font></a>&nbsp;&middot;
<a href="functions.html">
<font color="#004faf">Functions</font></a>&nbsp;&middot;
<a href="files.html">
<font color="#004faf">Files</font></a>
</td>
</tr>
</table>
<!-- Generated by Doxygen 1.7.5 -->
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="a00655.html">Tp</a>      </li>
      <li class="navelem"><a class="el" href="a00031.html">AbstractClientHandler</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">Tp::AbstractClientHandler Class Reference<div class="ingroups"><a class="el" href="a00671.html">Client proxies</a></div></div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Tp::AbstractClientHandler" --><!-- doxytag: inherits="Tp::AbstractClient" -->
<p>The <a class="el" href="a00031.html" title="The AbstractClientHandler class represents a Telepathy handler.">AbstractClientHandler</a> class represents a Telepathy handler.  
 <a href="a00031.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00412_source.html">TelepathyQt4/AbstractClientHandler</a>&gt;</code></p>

<p>Inherits <a class="el" href="a00029.html">Tp::AbstractClient</a>.</p>

<p>Inherited by <a class="el" href="a00367.html">Tp::SimpleStreamTubeHandler</a>.</p>

<p><a href="a00709.html">List of all members.</a></p>
<h2><a name="nested-classes"></a>
Classes</h2>
<ul>
<li>class <a class="el" href="a00073.html">Capabilities</a>
<dl class="el"><dd class="mdescRight">The <a class="el" href="a00073.html" title="The AbstractClientHandler::Capabilities class provides a wrapper around the capabilities of a handler...">AbstractClientHandler::Capabilities</a> class provides a wrapper around the capabilities of a handler.  <a href="a00073.html#details">More...</a><br/></dl><li>class <a class="el" href="a00220.html">HandlerInfo</a>
<dl class="el"><dd class="mdescRight">The <a class="el" href="a00220.html" title="The AbstractClientHandler::HandlerInfo class provides a wrapper around the additional info about the ...">AbstractClientHandler::HandlerInfo</a> class provides a wrapper around the additional info about the channels passed to <a class="el" href="a00031.html#abc44780bc349b383e6be81582de1866c">handleChannels()</a>.  <a href="a00220.html#details">More...</a><br/></dl></ul>
<h2><a name="pub-methods"></a>
Public Member Functions</h2>
<ul>
<li>virtual <a class="el" href="a00031.html#aecbb5e17a9494e9e25b95447b92664ad">~AbstractClientHandler</a> ()
<li>bool <a class="el" href="a00031.html#a8ffd86f4615baacbb6037444ac5145e2">isRegistered</a> () const 
<li><a class="el" href="a00081.html">ChannelClassSpecList</a> <a class="el" href="a00031.html#ae8164789b2f1c73c3d9eb9c768ee2d2d">handlerFilter</a> () const 
<li><a class="el" href="a00073.html">Capabilities</a> <a class="el" href="a00031.html#a66a39770b504442eace51e2d100e0882">handlerCapabilities</a> () const 
<li>virtual bool <a class="el" href="a00031.html#abe174258a56c37021f52aacbc83bedbf">bypassApproval</a> () const =0
<li>virtual void <a class="el" href="a00031.html#abc44780bc349b383e6be81582de1866c">handleChannels</a> (const MethodInvocationContextPtr&lt;&gt; &amp;context, const AccountPtr &amp;account, const ConnectionPtr &amp;connection, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qlist.html">QList</a>&lt; ChannelPtr &gt; &amp;channels, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qlist.html">QList</a>&lt; ChannelRequestPtr &gt; &amp;requestsSatisfied, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdatetime.html">QDateTime</a> &amp;userActionTime, const <a class="el" href="a00220.html">HandlerInfo</a> &amp;handlerInfo)=0
<li>bool <a class="el" href="a00031.html#ad2068126fa3fe0aae0c9247d98fb1ed7">wantsRequestNotification</a> () const 
<li>virtual void <a class="el" href="a00031.html#af5e487d62397b34cd5285d7492f50c57">addRequest</a> (const ChannelRequestPtr &amp;request)
<li>virtual void <a class="el" href="a00031.html#a4712b474e5669b309a67fd4ab1f702c5">removeRequest</a> (const ChannelRequestPtr &amp;request, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;errorName, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;errorMessage)
</ul>
<h2><a name="pro-methods"></a>
Protected Member Functions</h2>
<ul>
<li><a class="el" href="a00031.html#aaddc269dd6bd2ac7b3c1594189cf52b7">AbstractClientHandler</a> (const <a class="el" href="a00081.html">ChannelClassSpecList</a> &amp;channelFilter, const <a class="el" href="a00073.html">Capabilities</a> &amp;capabilities=<a class="el" href="a00073.html">Capabilities</a>(), bool wantsRequestNotification=false)
</ul>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="a00031.html" title="The AbstractClientHandler class represents a Telepathy handler.">AbstractClientHandler</a> class represents a Telepathy handler. </p>
<p>Handlers are the user interface for a channel. They turn an abstract channel into something the user wants to see, like a text message stream or an audio and/or video call.</p>
<p>For its entire lifetime, each channel on a connection known to the channel dispatcher is either being processed by the channel dispatcher, or being handled by precisely one handler.</p>
<p>Because each channel is only handled by one handler, handlers may perform actions that only make sense to do once, such as acknowledging text messages, transferring the file, etc.</p>
<p>When a new incoming channel is offered to approvers by the channel dispatcher, it also offers the approvers a list of all the running or activatable handlers whose filter indicates that they are able to handle the channel. The approvers can choose one of those channel handlers to handle the channel.</p>
<p>When a new outgoing channel appears, the channel dispatcher passes it to an appropriate channel handler automatically.</p>
<p>To become an handler one should inherit <a class="el" href="a00031.html" title="The AbstractClientHandler class represents a Telepathy handler.">AbstractClientHandler</a> and implement the pure virtual <a class="el" href="a00031.html#abe174258a56c37021f52aacbc83bedbf">bypassApproval()</a> and <a class="el" href="a00031.html#abc44780bc349b383e6be81582de1866c">handleChannels()</a> methods. After that the object representing the handler must be registered using <a class="el" href="a00125.html#a18c094053cc83809a167370f7113341b">ClientRegistrar::registerClient()</a>.</p>
<p>When new channels in which the approver has registered an interest are ready to be handled, the method <a class="el" href="a00031.html#abc44780bc349b383e6be81582de1866c">handleChannels()</a> is invoked.</p>
<h2><a class="anchor" id="handler_usage_sec"></a>
Usage</h2>
<h3><a class="anchor" id="handler_create_sec"></a>
Implementing a handler</h3>
<div class="fragment"><pre class="fragment"> <span class="keyword">class </span>MyHandler : <span class="keyword">public</span> <a class="code" href="a00031.html#aaddc269dd6bd2ac7b3c1594189cf52b7">AbstractClientHandler</a>
 {
 <span class="keyword">public</span>:
     MyHandler(<span class="keyword">const</span> ChannelClassSpecList &amp;channelFilter);
     ~MyHandler() { }

     <span class="keywordtype">void</span> <a class="code" href="a00031.html#abe174258a56c37021f52aacbc83bedbf">bypassApproval</a>() <span class="keyword">const</span>;

     <span class="keywordtype">void</span> <a class="code" href="a00031.html#abc44780bc349b383e6be81582de1866c">handleChannels</a>(<span class="keyword">const</span> MethodInvocationContextPtr&lt;&gt; &amp;context,
             <span class="keyword">const</span> AccountPtr &amp;account,
             <span class="keyword">const</span> ConnectionPtr &amp;connection,
             <span class="keyword">const</span> <a class="codeRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qlist.html">QList&lt;ChannelPtr&gt;</a> &amp;channels,
             <span class="keyword">const</span> <a class="codeRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qlist.html">QList&lt;ChannelRequestPtr&gt;</a> &amp;requestsSatisfied,
             <span class="keyword">const</span> <a class="codeRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdatetime.html">QDateTime</a> &amp;userActionTime,
             <span class="keyword">const</span> AbstractClientHandler::HandlerInfo &amp;handlerInfo);
 };

 MyHandler::MyHandler(<span class="keyword">const</span> ChannelClassSpecList &amp;channelFilter)
     : <a class="code" href="a00031.html#aaddc269dd6bd2ac7b3c1594189cf52b7">AbstractClientHandler</a>(channelFilter)
 {
 }

 <span class="keywordtype">void</span> MyHandler::bypassApproval()<span class="keyword"> const</span>
<span class="keyword"> </span>{
     <span class="keywordflow">return</span> <span class="keyword">false</span>;
 }

 <span class="keywordtype">void</span> MyHandler::handleChannels(<span class="keyword">const</span> MethodInvocationContextPtr&lt;&gt; &amp;context,
         <span class="keyword">const</span> AccountPtr &amp;account,
         <span class="keyword">const</span> ConnectionPtr &amp;connection,
         <span class="keyword">const</span> <a class="codeRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qlist.html">QList&lt;ChannelPtr&gt;</a> &amp;channels,
         <span class="keyword">const</span> <a class="codeRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qlist.html">QList&lt;ChannelRequestPtr&gt;</a> &amp;requestsSatisfied,
         <span class="keyword">const</span> <a class="codeRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdatetime.html">QDateTime</a> &amp;userActionTime,
         <span class="keyword">const</span> AbstractClientHandler::HandlerInfo &amp;handlerInfo)
 {
     <span class="comment">// do something</span>

     context-&gt;setFinished();
 }
</pre></div><h3><a class="anchor" id="handler_register_sec"></a>
Registering a handler</h3>
<div class="fragment"><pre class="fragment"> <a class="code" href="a00031.html#a331089a01aaa4211ca68c6f271fa2957">ClientRegistrar</a> registrar = <a class="code" href="a00125.html#a82f69f7d62e78d263ac26e5f7b51f523">ClientRegistrar::create</a>();
 AbstractClientPtr handler = AbstractClientPtr::dynamicCast(
         SharedPtr&lt;MyHandler&gt;(<span class="keyword">new</span> MyHandler(
             ChannelClassSpecList() &lt;&lt; <a class="code" href="a00080.html#a8396208afbe06b3b565e301321243adb">ChannelClassSpec::textChat</a>())));
 registrar-&gt;registerClient(handler, <span class="stringliteral">&quot;myhandler&quot;</span>);
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00029.html" title="The AbstractClient class represents a Telepathy client.">AbstractClient</a> </dd></dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aecbb5e17a9494e9e25b95447b92664ad"></a><!-- doxytag: member="Tp::AbstractClientHandler::~AbstractClientHandler" ref="aecbb5e17a9494e9e25b95447b92664ad" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tp::AbstractClientHandler::~AbstractClientHandler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Class destructor. </p>

</div>
</div>
<a class="anchor" id="aaddc269dd6bd2ac7b3c1594189cf52b7"></a><!-- doxytag: member="Tp::AbstractClientHandler::AbstractClientHandler" ref="aaddc269dd6bd2ac7b3c1594189cf52b7" args="(const ChannelClassSpecList &amp;channelFilter, const Capabilities &amp;capabilities=Capabilities(), bool wantsRequestNotification=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tp::AbstractClientHandler::AbstractClientHandler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00081.html">ChannelClassSpecList</a> &amp;&#160;</td>
          <td class="paramname"><em>channelFilter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00073.html">Capabilities</a> &amp;&#160;</td>
          <td class="paramname"><em>capabilities</em> = <code><a class="el" href="a00073.html">Capabilities</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wantsRequestNotification</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a new <a class="el" href="a00031.html" title="The AbstractClientHandler class represents a Telepathy handler.">AbstractClientHandler</a> object.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">channelFilter</td><td>A specification of the channels in which this observer is interested. </td></tr>
    <tr><td class="paramname">wantsRequestNotification</td><td>Whether this handler wants to receive channel requests notification via <a class="el" href="a00031.html#af5e487d62397b34cd5285d7492f50c57">addRequest()</a> and <a class="el" href="a00031.html#a4712b474e5669b309a67fd4ab1f702c5">removeRequest()</a>. </td></tr>
    <tr><td class="paramname">capabilities</td><td>The set of additional capabilities supported by this handler. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a8ffd86f4615baacbb6037444ac5145e2"></a><!-- doxytag: member="Tp::AbstractClientHandler::isRegistered" ref="a8ffd86f4615baacbb6037444ac5145e2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Tp::AbstractClientHandler::isRegistered </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return whether this handler is registered.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if registered, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ae8164789b2f1c73c3d9eb9c768ee2d2d"></a><!-- doxytag: member="Tp::AbstractClientHandler::handlerFilter" ref="ae8164789b2f1c73c3d9eb9c768ee2d2d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00081.html">ChannelClassSpecList</a> Tp::AbstractClientHandler::handlerFilter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the property containing a specification of the channels that this channel handler can deal with. It will be offered to approvers as a potential channel handler for bundles that contain only suitable channels, or for suitable channels that must be handled separately.</p>
<p>This method works in exactly the same way as the AbstractClientObserver::observerChannelFilter() method. In particular, the returned value cannot change while the handler process continues to own the corresponding client bus name.</p>
<p>In the .client file, represented in the same way as observer channel filter, the group is <a class="el" href="a00682.html#ga5f1663deeb4990651117d1e8ac54767c">TP_QT4_IFACE_CLIENT_HANDLER</a> suffixed by HandlerChannelFilter instead.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A specification of the channels that this channel handler can deal with as a list of <a class="el" href="a00080.html" title="The ChannelClassSpec class represents a Telepathy channel class.">ChannelClassSpec</a> objects. </dd></dl>

</div>
</div>
<a class="anchor" id="a66a39770b504442eace51e2d100e0882"></a><!-- doxytag: member="Tp::AbstractClientHandler::handlerCapabilities" ref="a66a39770b504442eace51e2d100e0882" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00073.html">AbstractClientHandler::Capabilities</a> Tp::AbstractClientHandler::handlerCapabilities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the set of additional capabilities supported by this handler.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The capabilities as an <a class="el" href="a00073.html" title="The AbstractClientHandler::Capabilities class provides a wrapper around the capabilities of a handler...">AbstractClientHandler::Capabilities</a> object. </dd></dl>

</div>
</div>
<a class="anchor" id="abe174258a56c37021f52aacbc83bedbf"></a><!-- doxytag: member="Tp::AbstractClientHandler::bypassApproval" ref="abe174258a56c37021f52aacbc83bedbf" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Tp::AbstractClientHandler::bypassApproval </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return whether channels destined for this handler are automatically handled, without invoking approvers.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if automatically handled, <code>false</code> otherwise. </dd></dl>

<p>Implemented in <a class="el" href="a00367.html#a572b7e13f4c8b956080f849dc999ad05">Tp::SimpleStreamTubeHandler</a>.</p>

</div>
</div>
<a class="anchor" id="abc44780bc349b383e6be81582de1866c"></a><!-- doxytag: member="Tp::AbstractClientHandler::handleChannels" ref="abc44780bc349b383e6be81582de1866c" args="(const MethodInvocationContextPtr&lt;&gt; &amp;context, const AccountPtr &amp;account, const ConnectionPtr &amp;connection, const QList&lt; ChannelPtr &gt; &amp;channels, const QList&lt; ChannelRequestPtr &gt; &amp;requestsSatisfied, const QDateTime &amp;userActionTime, const HandlerInfo &amp;handlerInfo)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tp::AbstractClientHandler::handleChannels </td>
          <td>(</td>
          <td class="paramtype">const MethodInvocationContextPtr&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AccountPtr &amp;&#160;</td>
          <td class="paramname"><em>account</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConnectionPtr &amp;&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qlist.html">QList</a>&lt; ChannelPtr &gt; &amp;&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qlist.html">QList</a>&lt; ChannelRequestPtr &gt; &amp;&#160;</td>
          <td class="paramname"><em>requestsSatisfied</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdatetime.html">QDateTime</a> &amp;&#160;</td>
          <td class="paramname"><em>userActionTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00220.html">HandlerInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>handlerInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called by the channel dispatcher when this handler should handle these channels, or when this handler should present channels that it is already handling to the user (e.g. bring them into the foreground).</p>
<p>Clients are expected to know what channels they're already handling, and which channel object corresponds to which window or tab.</p>
<p>After <a class="el" href="a00031.html#abc44780bc349b383e6be81582de1866c">handleChannels()</a> replies successfully by calling <a class="el" href="a00269.html#aa3c875e9ae94857386fb612324cfe205">MethodInvocationContext::setFinished()</a>, the client process is considered to be responsible for the channel until it its unique name disappears from the bus.</p>
<p>If a process has multiple client bus names - some temporary and some long-lived - and drops one of the temporary bus names in order to reduce the set of channels that it will handle, any channels that it is already handling will remain unaffected.</p>
<p>The received <em>context</em> object should be stored until this method is finished processing and then <a class="el" href="a00269.html#aa3c875e9ae94857386fb612324cfe205">MethodInvocationContext::setFinished()</a> or <a class="el" href="a00269.html#a43e5556ab1aa8c3fb7bfd5a0bd77becf">MethodInvocationContext::setFinishedWithError()</a> should be called on the received <em>context</em> object.</p>
<p>Specialized handlers must reimplement this method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>A MethodInvocationContextPtr object that must be used to indicate whether this method finished processing. </td></tr>
    <tr><td class="paramname">account</td><td>The account with which the channels are associated. </td></tr>
    <tr><td class="paramname">connection</td><td>The connection with which the channels are associated. </td></tr>
    <tr><td class="paramname">channels</td><td>The channels to be handled. </td></tr>
    <tr><td class="paramname">dispatchOperation</td><td>The dispatch operation for these channels. The object will be invalid (<a class="el" href="a00195.html#adb39028a597488f81d5f8bacfe822886">DBusProxy::isValid()</a> will be false) if there is no dispatch operation in place (because the channels were requested, not incoming). </td></tr>
    <tr><td class="paramname">requestsSatisfied</td><td>The requests satisfied by these channels. </td></tr>
    <tr><td class="paramname">userActionTime</td><td>The time at which user action occurred, or 0 if this channel is to be handled for some reason not involving user action. Handlers should use this for focus-stealing prevention, if applicable. </td></tr>
    <tr><td class="paramname">handlerInfo</td><td>Additional information about these channels. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="a00367.html#a2e03f9d5f5e7b79690a6ceb37e200a60">Tp::SimpleStreamTubeHandler</a>.</p>

</div>
</div>
<a class="anchor" id="ad2068126fa3fe0aae0c9247d98fb1ed7"></a><!-- doxytag: member="Tp::AbstractClientHandler::wantsRequestNotification" ref="ad2068126fa3fe0aae0c9247d98fb1ed7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Tp::AbstractClientHandler::wantsRequestNotification </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return whether this handler wants to receive notification of channel requests via <a class="el" href="a00031.html#af5e487d62397b34cd5285d7492f50c57">addRequest()</a> and <a class="el" href="a00031.html#a4712b474e5669b309a67fd4ab1f702c5">removeRequest()</a>.</p>
<p>This property is set by the constructor and cannot be changed after that.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if receiving channel requests notification is desired, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="af5e487d62397b34cd5285d7492f50c57"></a><!-- doxytag: member="Tp::AbstractClientHandler::addRequest" ref="af5e487d62397b34cd5285d7492f50c57" args="(const ChannelRequestPtr &amp;request)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tp::AbstractClientHandler::addRequest </td>
          <td>(</td>
          <td class="paramtype">const ChannelRequestPtr &amp;&#160;</td>
          <td class="paramname"><em>channelRequest</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called by the channel dispatcher to indicate that channels have been requested, and that if the request is successful, they will probably be handled by this handler.</p>
<p>This allows the UI to start preparing to handle the channels in advance (e.g. render a window with an "in progress" message), improving perceived responsiveness.</p>
<p>If the request succeeds and is given to the expected handler, the requestsSatisfied parameter to <a class="el" href="a00031.html#abc44780bc349b383e6be81582de1866c">handleChannels()</a> can be used to match the channel to a previous <a class="el" href="a00031.html#af5e487d62397b34cd5285d7492f50c57">addRequest()</a> call.</p>
<p>This lets the UI direct the channels to the window that it already opened.</p>
<p>If the request fails, the expected handler is notified by the channel dispatcher calling its <a class="el" href="a00031.html#a4712b474e5669b309a67fd4ab1f702c5">removeRequest()</a> method.</p>
<p>This lets the UI close the window or display the error.</p>
<p>The channel dispatcher will attempt to ensure that <a class="el" href="a00031.html#abc44780bc349b383e6be81582de1866c">handleChannels()</a> is called on the same handler that received <a class="el" href="a00031.html#af5e487d62397b34cd5285d7492f50c57">addRequest()</a>. If that isn't possible, <a class="el" href="a00031.html#a4712b474e5669b309a67fd4ab1f702c5">removeRequest()</a> will be called on the handler that previously received <a class="el" href="a00031.html#af5e487d62397b34cd5285d7492f50c57">addRequest()</a>, with the special error <a class="el" href="a00683.html#ga18f306a275c421e6baab5865ec35d854">TP_QT4_ERROR_NOT_YOURS</a>, which indicates that some other handler received the channel instead.</p>
<p>Expected handling is for the UI to close the window it previously opened.</p>
<p>Specialized handlers that want to be notified of newly requested channel should reimplement this method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">channelRequest</td><td>The newly created channel request. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00031.html#a4712b474e5669b309a67fd4ab1f702c5">removeRequest()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4712b474e5669b309a67fd4ab1f702c5"></a><!-- doxytag: member="Tp::AbstractClientHandler::removeRequest" ref="a4712b474e5669b309a67fd4ab1f702c5" args="(const ChannelRequestPtr &amp;request, const QString &amp;errorName, const QString &amp;errorMessage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tp::AbstractClientHandler::removeRequest </td>
          <td>(</td>
          <td class="paramtype">const ChannelRequestPtr &amp;&#160;</td>
          <td class="paramname"><em>channelRequest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>errorName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>errorMessage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called by the ChannelDispatcher to indicate that a request previously passed to <a class="el" href="a00031.html#af5e487d62397b34cd5285d7492f50c57">addRequest()</a> has failed and should be disregarded.</p>
<p>Specialized handlers that want to be notified of removed channel requests should reimplement this method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">channelRequest</td><td>The channel request that failed. </td></tr>
    <tr><td class="paramname">errorName</td><td>The name of the D-Bus error with which the request failed. If this is <a class="el" href="a00683.html#ga18f306a275c421e6baab5865ec35d854">TP_QT4_ERROR_NOT_YOURS</a>, this indicates that the request succeeded, but all the resulting channels were given to some other handler. </td></tr>
    <tr><td class="paramname">errorMessage</td><td>Any message supplied with the D-Bus error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td width="30%">Copyright &copy; 2008-2011 Collabora Ltd. and Nokia Corporation</td>
<td width="30%" align="right"><div align="right">Telepathy-Qt4 0.8.0</div></td>
</tr></table></div></address>
</body>
</html>
