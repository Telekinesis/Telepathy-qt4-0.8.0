<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Tp::Client::ClientObserverInterface Class Reference</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td width="1">&nbsp;&nbsp;</td>
<td class="postheader" valign="center">
<a href="index.html">
<font color="#004faf">Home</font></a>&nbsp;&middot;
<a href="classes.html">
<font color="#004faf">All Classes</font></a>&nbsp;&middot;
<a href="namespaces.html">
<font color="#004faf">All Namespaces</font></a>&nbsp;&middot;
<a href="modules.html">
<font color="#004faf">Modules</font></a>&nbsp;&middot;
<a href="functions.html">
<font color="#004faf">Functions</font></a>&nbsp;&middot;
<a href="files.html">
<font color="#004faf">Files</font></a>
</td>
</tr>
</table>
<!-- Generated by Doxygen 1.7.5 -->
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="a00655.html">Tp</a>      </li>
      <li class="navelem"><a class="el" href="a00659.html">Client</a>      </li>
      <li class="navelem"><a class="el" href="a00124.html">ClientObserverInterface</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-slots">Public Slots</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">Tp::Client::ClientObserverInterface Class Reference<div class="ingroups"><a class="el" href="a00671.html">Client proxies</a></div></div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Tp::Client::ClientObserverInterface" --><!-- doxytag: inherits="Tp::AbstractInterface" -->
<p><code>#include &lt;<a class="el" href="a00463_source.html">TelepathyQt4/Client</a>&gt;</code></p>

<p>Inherits <a class="el" href="a00033.html">Tp::AbstractInterface</a>.</p>

<p><a href="a00950.html">List of all members.</a></p>
<h2><a name="pub-slots"></a>
Public Slots</h2>
<ul>
<li><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbuspendingreply.html">QDBusPendingReply</a> <a class="el" href="a00124.html#aa39e6aec3617c1390535b892196391ee">ObserveChannels</a> (const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusobjectpath.html">QDBusObjectPath</a> &amp;account, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusobjectpath.html">QDBusObjectPath</a> &amp;<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusabstractinterface.html#connection">connection</a>, const <a class="el" href="a00685.html#ga7014d699ff46041f3c88a396205ba4c0">Tp::ChannelDetailsList</a> &amp;channels, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusobjectpath.html">QDBusObjectPath</a> &amp;dispatchOperation, const <a class="el" href="a00276.html">Tp::ObjectPathList</a> &amp;requestsSatisfied, const QVariantMap &amp;observerInfo, int <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusabstractinterface.html#timeout">timeout</a>=-1)
</ul>
<h2><a name="pub-methods"></a>
Public Member Functions</h2>
<ul>
<li><a class="el" href="a00124.html#a1764511b2499f753b122856604ee9dc3">ClientObserverInterface</a> (const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;busName, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;objectPath, <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qobject.html">QObject</a> *<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qobject.html#parent">parent</a>=0)
<li><a class="el" href="a00124.html#ae5eef9e6dccaf18d352924acfb26af93">ClientObserverInterface</a> (const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusconnection.html">QDBusConnection</a> &amp;<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusabstractinterface.html#connection">connection</a>, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;busName, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;objectPath, <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qobject.html">QObject</a> *<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qobject.html#parent">parent</a>=0)
<li><a class="el" href="a00124.html#ae68920bd0dd07340d4ca617610491e6d">ClientObserverInterface</a> (<a class="el" href="a00195.html">Tp::DBusProxy</a> *proxy)
<li><a class="el" href="a00124.html#a9e99b32acf94e9a2ac7ab683ab8ab01e">ClientObserverInterface</a> (const <a class="el" href="a00122.html">Tp::Client::ClientInterface</a> &amp;mainInterface)
<li><a class="el" href="a00124.html#ab0cc02daf9f5e05e4ba0bd58ba54927c">ClientObserverInterface</a> (const <a class="el" href="a00122.html">Tp::Client::ClientInterface</a> &amp;mainInterface, <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qobject.html">QObject</a> *<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qobject.html#parent">parent</a>)
<li><a class="el" href="a00309.html">Tp::PendingVariant</a> * <a class="el" href="a00124.html#aa419ddfd381d4aac1b0072988db60cff">requestPropertyObserverChannelFilter</a> () const 
<li><a class="el" href="a00309.html">Tp::PendingVariant</a> * <a class="el" href="a00124.html#a78fc6c230151bfdee93a0c0ef2ca0eff">requestPropertyRecover</a> () const 
<li><a class="el" href="a00309.html">Tp::PendingVariant</a> * <a class="el" href="a00124.html#abb05b659bc798a9799d33f53432ffa97">requestPropertyDelayApprovers</a> () const 
<li><a class="el" href="a00310.html">Tp::PendingVariantMap</a> * <a class="el" href="a00124.html#ae4b93bee74564d07a0f9639015f12a63">requestAllProperties</a> () const 
</ul>
<h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2>
<ul>
<li>static <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qlatin1string.html">QLatin1String</a> <a class="el" href="a00124.html#ad6c750e5f82869b1ed3bbe596eec66d5">staticInterfaceName</a> ()
</ul>
<h2><a name="pro-methods"></a>
Protected Member Functions</h2>
<ul>
<li>virtual void <a class="el" href="a00124.html#ad2e400ad845c2ef4857c5f89ec0ce625">invalidate</a> (<a class="el" href="a00195.html">Tp::DBusProxy</a> *, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;)
</ul>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Client.Observer." </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a1764511b2499f753b122856604ee9dc3"></a><!-- doxytag: member="Tp::Client::ClientObserverInterface::ClientObserverInterface" ref="a1764511b2499f753b122856604ee9dc3" args="(const QString &amp;busName, const QString &amp;objectPath, QObject *parent=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tp::Client::ClientObserverInterface::ClientObserverInterface </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>busName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>objectPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qobject.html">QObject</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a <a class="el" href="a00124.html">ClientObserverInterface</a> associated with the given object on the session bus.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">busName</td><td>Name of the service the object is on. </td></tr>
    <tr><td class="paramname">objectPath</td><td>Path to the object on the service. </td></tr>
    <tr><td class="paramname">parent</td><td>Passed to the parent class constructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae5eef9e6dccaf18d352924acfb26af93"></a><!-- doxytag: member="Tp::Client::ClientObserverInterface::ClientObserverInterface" ref="ae5eef9e6dccaf18d352924acfb26af93" args="(const QDBusConnection &amp;connection, const QString &amp;busName, const QString &amp;objectPath, QObject *parent=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tp::Client::ClientObserverInterface::ClientObserverInterface </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusconnection.html">QDBusConnection</a> &amp;&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>busName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>objectPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qobject.html">QObject</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a <a class="el" href="a00124.html">ClientObserverInterface</a> associated with the given object on the given bus.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">connection</td><td>The bus via which the object can be reached. </td></tr>
    <tr><td class="paramname">busName</td><td>Name of the service the object is on. </td></tr>
    <tr><td class="paramname">objectPath</td><td>Path to the object on the service. </td></tr>
    <tr><td class="paramname">parent</td><td>Passed to the parent class constructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae68920bd0dd07340d4ca617610491e6d"></a><!-- doxytag: member="Tp::Client::ClientObserverInterface::ClientObserverInterface" ref="ae68920bd0dd07340d4ca617610491e6d" args="(Tp::DBusProxy *proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tp::Client::ClientObserverInterface::ClientObserverInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00195.html">Tp::DBusProxy</a> *&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a <a class="el" href="a00124.html">ClientObserverInterface</a> associated with the same object as the given proxy.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The proxy to use. It will also be the <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qobject.html#parent">QObject::parent()</a> for this object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9e99b32acf94e9a2ac7ab683ab8ab01e"></a><!-- doxytag: member="Tp::Client::ClientObserverInterface::ClientObserverInterface" ref="a9e99b32acf94e9a2ac7ab683ab8ab01e" args="(const Tp::Client::ClientInterface &amp;mainInterface)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tp::Client::ClientObserverInterface::ClientObserverInterface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00122.html">Tp::Client::ClientInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>mainInterface</em></td><td>)</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a <a class="el" href="a00124.html">ClientObserverInterface</a> associated with the same object as the given proxy. Additionally, the created proxy will have the same parent as the given proxy.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mainInterface</td><td>The proxy to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab0cc02daf9f5e05e4ba0bd58ba54927c"></a><!-- doxytag: member="Tp::Client::ClientObserverInterface::ClientObserverInterface" ref="ab0cc02daf9f5e05e4ba0bd58ba54927c" args="(const Tp::Client::ClientInterface &amp;mainInterface, QObject *parent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tp::Client::ClientObserverInterface::ClientObserverInterface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00122.html">Tp::Client::ClientInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>mainInterface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qobject.html">QObject</a> *&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a <a class="el" href="a00124.html">ClientObserverInterface</a> associated with the same object as the given proxy. However, a different parent object can be specified.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mainInterface</td><td>The proxy to use. </td></tr>
    <tr><td class="paramname">parent</td><td>Passed to the parent class constructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ad6c750e5f82869b1ed3bbe596eec66d5"></a><!-- doxytag: member="Tp::Client::ClientObserverInterface::staticInterfaceName" ref="ad6c750e5f82869b1ed3bbe596eec66d5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qlatin1string.html">QLatin1String</a> Tp::Client::ClientObserverInterface::staticInterfaceName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the name of the interface "org.freedesktop.Telepathy.Client.Observer", which this class represents.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The D-Bus interface name. </dd></dl>

</div>
</div>
<a class="anchor" id="aa419ddfd381d4aac1b0072988db60cff"></a><!-- doxytag: member="Tp::Client::ClientObserverInterface::requestPropertyObserverChannelFilter" ref="aa419ddfd381d4aac1b0072988db60cff" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00309.html">Tp::PendingVariant</a>* Tp::Client::ClientObserverInterface::requestPropertyObserverChannelFilter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property <code>ObserverChannelFilter</code> of type <code><a class="el" href="a00685.html#ga635ae458e9972df8168a2467b8a9a667">Tp::ChannelClassList</a></code>.</p>
 
         <p>A specification of the channels in which this observer is
           interested. The   <a class="el" href="a00124.html#aa39e6aec3617c1390535b892196391ee">ObserveChannels()</a>  method
           should be called by the channel dispatcher whenever any of the new
           channels in a   <a class="el" href="a00148.html#aa9fda39dba52244626a87535073b85bd">ConnectionInterfaceRequestsInterface::NewChannels()</a>  
           signal match this description.</p>
 
         <p>Only certain D-Bus types have useful semantics for matching like this,
           so only certain types are allowed:</p>
 
         <dl>
           <dt>Integers of all sizes, including byte (y, n, q, i, u, x, t)</dt>
           <dd>Matched by numeric value, regardless of type (e.g. 42 as a
             16-bit signed integer 'n' is considered equal to 42 as a 32-bit
             unsigned integer 'u')</dd>
 
           <dt>Booleans (b)</dt>
           <dd>Matched by equality in the obvious way; not considered equal to any
             other type</dd>
 
           <dt>Strings (s)</dt>
           <dd>Matched by equality in the obvious way; not considered equal to any
             other type</dd>
 
           <dt>Object paths (o)</dt>
           <dd>Matched by equality in the obvious way; not considered equal to any
             other type</dd>
 
         </dl>
 
         <p>This property never changes while the observer process owns its
           Client bus name. For activatable processes, the filter can change
           due to an upgrade - the channel dispatcher SHOULD observe changes to
           .client files using a mechanism like inotify.</p>
 
         <div class="rationale">
           <p>Not allowing this property to change is a simplification,
             particularly for activatable processes (we reject the possibility
             that a process with a .client file, when activated, has a filter
             that differs from what its .client file said).</p>
 
           <p>If an Observer wants to add extra channels to its list of
             interests at runtime, it can register an additional Client bus name
             (for instance, the org.freedesktop.Telepathy.Client.Empathy process
             with unique name :1.42 could additionally register
             org.freedesktop.Telepathy.Client.Empathy._1_42) with additional
             filters. To remove those filters, it can release the bus name;
             it could even re-claim the bus name immediately, with different
             filters.</p>
 
           <p>The same principle is applied to Approvers and Handlers.</p>
         </div>
 
         <p>For observers that have a .client file, the channel dispatcher
           may discover this property from keys of the form
           &quot;<code><em>propertyname</em> <em>type</em></code>&quot;,
           in groups in the .client file whose name is the name of this
           interface followed by <code>.ObserverChannelFilter</code>,
           a space and an ASCII decimal number starting from 0.</p>
 
         <p>Values in the .client file are encoded in exactly the same way as
           the <code>default-<em>p</em></code> keys in .manager files, as
           described in the   <a class="el" href="a00153.html">ConnectionManagerInterface</a>  interface (but note that not all
           types supported in .manager files can appear in .client files).</p>
 
         <p>For instance, a .client file for an observer that is only interested
           in Text channels, with CONTACT or ROOM handles, that were requested by
           a local client:</p>
 
 <pre>
 [org.freedesktop.Telepathy.Client]
 Interfaces=org.freedesktop.Telepathy.Client.Observer;
 
 [org.freedesktop.Telepathy.Client.Observer.ObserverChannelFilter 0]
 org.freedesktop.Telepathy.Channel.ChannelType s=org.freedesktop.Telepathy.Channel.Type.Text
 org.freedesktop.Telepathy.Channel.TargetHandleType u=1
 org.freedesktop.Telepathy.Channel.Requested b=true
 
 [org.freedesktop.Telepathy.Client.Observer.ObserverChannelFilter 1]
 org.freedesktop.Telepathy.Channel.ChannelType s=org.freedesktop.Telepathy.Channel.Type.Text
 org.freedesktop.Telepathy.Channel.TargetHandleType u=2
 org.freedesktop.Telepathy.Channel.Requested b=true
 </pre>
 <dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="a78fc6c230151bfdee93a0c0ef2ca0eff"></a><!-- doxytag: member="Tp::Client::ClientObserverInterface::requestPropertyRecover" ref="a78fc6c230151bfdee93a0c0ef2ca0eff" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00309.html">Tp::PendingVariant</a>* Tp::Client::ClientObserverInterface::requestPropertyRecover </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property <code>Recover</code> of type <code>bool</code>.</p>
 
         <p>If true, upon the startup of this observer,   <a class="el" href="a00124.html#aa39e6aec3617c1390535b892196391ee">ClientObserverInterface::ObserveChannels()</a>  
         will be called for every already existing channel matching
         its   <a class="el" href="a00124.html#aa419ddfd381d4aac1b0072988db60cff">ClientObserverInterface::ObserverChannelFilter </a>  </p>
 
         <p>When an activatable client having this property disappears from the
           bus and there are channels matching its ObserverChannelFilter,
           ObserveChannels will be called immediately to reactivate it
           again. Such clients should specify this property in their
           <tt>.client</tt> file as follows:</p>
 
 <pre>
 [org.freedesktop.Telepathy.Client.Observer]
 Recover=true
 </pre>
 
         <div class="rationale">
           <p>This means that if an activatable Observer crashes, it will
             be restarted as soon as possible; while there is an unavoidable
             possibility that it will miss some events during this process
             (particularly   <a class="el" href="a00117.html">ChannelTypeTextInterface</a>  
             messages), this window of event loss is kept to a minimum.</p>
 
            <p>Non-activatable observers can't take advantage of this
             mechanism, but setting this property on a non-activatable
             observer does allow it to &quot;catch up&quot; on channels that are
             currently active at the time that it starts up.</p>
         </div>
 
         <p>When the ObserveChannels method is called due to observer recovery,
         the <var>Observer_Info</var> dictionary will contain one extra item
         mapping the key <code>&quot;recovering&quot;</code> to <code>True</code>.</p>
 <dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="abb05b659bc798a9799d33f53432ffa97"></a><!-- doxytag: member="Tp::Client::ClientObserverInterface::requestPropertyDelayApprovers" ref="abb05b659bc798a9799d33f53432ffa97" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00309.html">Tp::PendingVariant</a>* Tp::Client::ClientObserverInterface::requestPropertyDelayApprovers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property <code>DelayApprovers</code> of type <code>bool</code>.</p>
 
           <p>If true, the channel dispatcher will wait for
               <a class="el" href="a00124.html#aa39e6aec3617c1390535b892196391ee">ObserveChannels()</a>  to return
             before calling   <a class="el" href="a00120.html#a3c8f2cd19bc110b3674ba42933485031">ClientApproverInterface::AddDispatchOperation()</a>  
             on appropriate Approvers.</p>
 
           <p>This property SHOULD be false unless there is a reason
             why a channel should not be given to approvers. An example
             of this is if an Observer is also a Handler and wants to
               <a class="el" href="a00085.html#a1a519eae4cfd367598370d95107f18d4">ChannelDispatchOperationInterface::Claim()</a>  
             a channel so that it becomes its handler and doesn't want
             any approver to be called, this property should be true.</p>
 
           <p>Observers and Approvers should be called at the same time
             in normal operation (with this property set to false) to
             improve responsiveness. For example, if an incoming call
             appears, the approver should get the channel as fast as
             possible to show a dialog, but if an approver has to make
             round-trips to set itself up, then the approval of the
             channel is delayed. As a result, it is recommended for this
             property to remain false unless absolutely necessary.</p>
 
           <p>For service-activatable clients, this property should be
             specified in the observer's <tt>.client</tt> file as
             follows:</p>
 
           <p>If this property is not implemented (telepathy-mission-control
             5.7.5 and older), the channel dispatcher SHOULD consider it as
             being false.</p>
 
 <pre>
 [org.freedesktop.Telepathy.Client.Observer]
 DelayApprovers=true
 </pre>
 <dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="ae4b93bee74564d07a0f9639015f12a63"></a><!-- doxytag: member="Tp::Client::ClientObserverInterface::requestAllProperties" ref="ae4b93bee74564d07a0f9639015f12a63" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00310.html">Tp::PendingVariantMap</a>* Tp::Client::ClientObserverInterface::requestAllProperties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Request all of the <a class="el" href="a00660.html">DBus</a> properties on the interface.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant map which will emit finished when the properties have been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="aa39e6aec3617c1390535b892196391ee"></a><!-- doxytag: member="Tp::Client::ClientObserverInterface::ObserveChannels" ref="aa39e6aec3617c1390535b892196391ee" args="(const QDBusObjectPath &amp;account, const QDBusObjectPath &amp;connection, const Tp::ChannelDetailsList &amp;channels, const QDBusObjectPath &amp;dispatchOperation, const Tp::ObjectPathList &amp;requestsSatisfied, const QVariantMap &amp;observerInfo, int timeout=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbuspendingreply.html">QDBusPendingReply</a> Tp::Client::ClientObserverInterface::ObserveChannels </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusobjectpath.html">QDBusObjectPath</a> &amp;&#160;</td>
          <td class="paramname"><em>account</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusobjectpath.html">QDBusObjectPath</a> &amp;&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00685.html#ga7014d699ff46041f3c88a396205ba4c0">Tp::ChannelDetailsList</a> &amp;&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusobjectpath.html">QDBusObjectPath</a> &amp;&#160;</td>
          <td class="paramname"><em>dispatchOperation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00276.html">Tp::ObjectPathList</a> &amp;&#160;</td>
          <td class="paramname"><em>requestsSatisfied</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVariantMap &amp;&#160;</td>
          <td class="paramname"><em>observerInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Begins a call to the D-Bus method <code>ObserveChannels</code> on the remote object.</p>
 
 <p>Called by the channel dispatcher when channels in which the
   observer has registered an interest are announced in a   <a class="el" href="a00148.html#aa9fda39dba52244626a87535073b85bd">ConnectionInterfaceRequestsInterface::NewChannels()</a>  
   signal.</p>
 
 <p>If the same NewChannels signal announces some channels that match
   the filter, and some that do not, then only a subset of the channels
   (those that do match the filter) are passed to this method.</p>
 
 <p>If the channel dispatcher will split up the channels from a single
   NewChannels signal and dispatch them separately (for instance
   because no installed Handler can handle all of them), it will call
   ObserveChannels several times.</p>
 
 <p>The observer MUST NOT return from this method call until it is ready
   for a handler for the channel to run (which may change the channel's
   state).</p>
 
 <div class="rationale">
   <p>The channel dispatcher must wait for observers to start up,
     to avoid the following race: text channel logger (observer) gets
     ObserveChannels, text channel handler gets
       <a class="el" href="a00121.html#a8a5614e91a82ede4761b6ba3e13724a1">ClientHandlerInterface::HandleChannels()</a>  
     channel handler starts up faster and acknowledges messages,
     logger never sees those messages.</p>
 </div>
 
 <p>The channel dispatcher SHOULD NOT change its behaviour based on
   whether this method succeeds or fails: there are no defined D-Bus
   errors for this method, and if it fails, this only indicates that
   an Observer is somehow broken.</p>
 
 <div class="rationale">
   <p>The expected error response in the channel dispatcher is to
     log a warning, and otherwise continue as though this method
     had succeeded.</p>
 </div>
 <p>Note that <em>timeout</em> is ignored as of now. It will be used once <a href="http://bugreports.qt.nokia.com/browse/QTBUG-11775">http://bugreports.qt.nokia.com/browse/QTBUG-11775</a> is fixed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">account</td><td>The <a class="el" href="a00035.html" title="The Account class represents a Telepathy account.">Account</a> with which the channels are associated. The well-known bus name to use is that of the <a class="el" href="a00042.html" title="The AccountManager class represents a Telepathy account manager.">AccountManager</a>.</td></tr>
    <tr><td class="paramname">connection</td><td>The <a class="el" href="a00127.html" title="The Connection class represents a Telepathy connection.">Connection</a> with which the channels are associated. The well-known bus name to use can be derived from this object path by removing the leading '/' and replacing all subsequent '/' by '.'.</td></tr>
    <tr><td class="paramname">channels</td><td>The Channels and their properties. Their well-known bus names are all the same as that of the <a class="el" href="a00127.html" title="The Connection class represents a Telepathy connection.">Connection</a>.</td></tr>
    <tr><td class="paramname">dispatchOperation</td><td> 
     <p>The path to the   <a class="el" href="a00085.html">ChannelDispatchOperationInterface</a>  
       for these channels, or the special value '/' if there is no
       ChannelDispatchOperation (because the channels were requested, not
       incoming).</p>
     
     <p>If the Observer calls   <a class="el" href="a00085.html#a1a519eae4cfd367598370d95107f18d4">ChannelDispatchOperationInterface::Claim()</a>  
       or   <a class="el" href="a00085.html#a4aa587c9c05a2ad0a74277c5ee7d80a2">ChannelDispatchOperationInterface::HandleWith()</a>  
       on the dispatch operation, it MUST be careful to avoid deadlock,
       since these methods cannot return until the Observer has returned
       from   <a class="el" href="a00124.html#aa39e6aec3617c1390535b892196391ee">ObserveChannels()</a>  .</p>
     
     <div class="rationale">
       <p>This allows an Observer to   <a class="el" href="a00085.html#a1a519eae4cfd367598370d95107f18d4">ChannelDispatchOperationInterface::Claim()</a>  
         a set of channels without having to match up calls to this method
         with calls to   <a class="el" href="a00120.html#a3c8f2cd19bc110b3674ba42933485031">ClientApproverInterface::AddDispatchOperation()</a>  .</p>
     </div>
     </td></tr>
    <tr><td class="paramname">requestsSatisfied</td><td>The ChannelRequests satisfied by these channels. If the same process is an Observer and a Handler, it can be useful to be given this information as soon as possible (it will also be passed to Handler.HandleChannels).</td></tr>
    <tr><td class="paramname">observerInfo</td><td> 
     <p>Additional information about these channels. Currently defined
       keys are:</p>
     
     <dl>
       <dt><code>recovering</code> - b</dt>
       <dd><code>True</code> if ObserveChannels was called for an existing
         channel (due to the   <a class="el" href="a00124.html#a78fc6c230151bfdee93a0c0ef2ca0eff">Recover </a>  
         property being <code>True</code>); <code>False</code> or omitted
         otherwise.
     
         <div class="rationale">
           This allows observers to distinguish between new channels (the normal
           case), and existing channels that were given to the observer in order
           to catch up on previous events (perhaps after a previous instance of
           the same observer crashed).
         </div>
       </dd>
     
       <dt><code>request-properties</code> - a{oa{sv}}</dt>
       <dd>A map from   <a class="el" href="a00107.html">ChannelRequestInterface</a>  
         paths listed in <var>Requests_Satisfied</var> to
         <tp:type>Qualified_Property_Value_Map</tp:type>s containing
         namespaced immutable properties of each request.</dd>
     </dl>
     
     <p>All defined keys for this dictionary are optional;
       observers MAY safely ignore any entry in this dictionary.</p>
      </td></tr>
    <tr><td class="paramname">timeout</td><td>The timeout in milliseconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad2e400ad845c2ef4857c5f89ec0ce625"></a><!-- doxytag: member="Tp::Client::ClientObserverInterface::invalidate" ref="ad2e400ad845c2ef4857c5f89ec0ce625" args="(Tp::DBusProxy *, const QString &amp;, const QString &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tp::Client::ClientObserverInterface::invalidate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00195.html">Tp::DBusProxy</a> *&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="a00033.html#a79dde56ba44455f47c7c354ada07467a">Tp::AbstractInterface</a>.</p>

</div>
</div>
</div>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td width="30%">Copyright &copy; 2008-2011 Collabora Ltd. and Nokia Corporation</td>
<td width="30%" align="right"><div align="right">Telepathy-Qt4 0.8.0</div></td>
</tr></table></div></address>
</body>
</html>
