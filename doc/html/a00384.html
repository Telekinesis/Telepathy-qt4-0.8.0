<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Tp::StreamTubeServer Class Reference</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td width="1">&nbsp;&nbsp;</td>
<td class="postheader" valign="center">
<a href="index.html">
<font color="#004faf">Home</font></a>&nbsp;&middot;
<a href="classes.html">
<font color="#004faf">All Classes</font></a>&nbsp;&middot;
<a href="namespaces.html">
<font color="#004faf">All Namespaces</font></a>&nbsp;&middot;
<a href="modules.html">
<font color="#004faf">Modules</font></a>&nbsp;&middot;
<a href="functions.html">
<font color="#004faf">Functions</font></a>&nbsp;&middot;
<a href="files.html">
<font color="#004faf">Files</font></a>
</td>
</tr>
</table>
<!-- Generated by Doxygen 1.7.5 -->
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="a00655.html">Tp</a>      </li>
      <li class="navelem"><a class="el" href="a00384.html">StreamTubeServer</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#signals">Signals</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">Tp::StreamTubeServer Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Tp::StreamTubeServer" --><!-- doxytag: inherits="QObject,Tp::RefCounted" -->
<p>The <a class="el" href="a00384.html" title="The StreamTubeServer class is a Handler implementation for outgoing Stream Tube channels, allowing an application to easily export a TCP network server over Telepathy Tubes without worrying about the channel dispatching details.">StreamTubeServer</a> class is a Handler implementation for outgoing Stream Tube channels, allowing an application to easily export a TCP network server over Telepathy Tubes without worrying about the channel dispatching details.  
 <a href="a00384.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00636_source.html">TelepathyQt4/StreamTubeServer</a>&gt;</code></p>

<p>Inherits <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qobject.html">QObject</a>, and <a class="el" href="a00336.html">Tp::RefCounted</a>.</p>

<p><a href="a00822.html">List of all members.</a></p>
<h2><a name="nested-classes"></a>
Classes</h2>
<ul>
<li>class <a class="el" href="a00288.html">ParametersGenerator</a>
<dl class="el"><dd class="mdescRight">The <a class="el" href="a00288.html" title="The StreamTubeServer::ParametersGenerator abstract interface allows sending a different set of parame...">StreamTubeServer::ParametersGenerator</a> abstract interface allows sending a different set of parameters with each tube offer.  <a href="a00288.html#details">More...</a><br/></dl><li>class <a class="el" href="a00338.html">RemoteContact</a>
<dl class="el"><dd class="mdescRight">The <a class="el" href="a00338.html" title="The StreamTubeServer::RemoteContact class represents a contact from which a socket connection to our ...">StreamTubeServer::RemoteContact</a> class represents a contact from which a socket connection to our exported socket originates.  <a href="a00338.html#details">More...</a><br/></dl><li>class <a class="el" href="a00394.html">Tube</a>
<dl class="el"><dd class="mdescRight">The <a class="el" href="a00394.html" title="The StreamTubeServer::Tube class represents a tube being handled by the server.">StreamTubeServer::Tube</a> class represents a tube being handled by the server.  <a href="a00394.html#details">More...</a><br/></dl></ul>
<h2><a name="signals"></a>
Signals</h2>
<ul>
<li>void <a class="el" href="a00384.html#a79863540c66e7370bfc31b76cefbc9e4">tubeRequested</a> (const Tp::AccountPtr &amp;account, const Tp::OutgoingStreamTubeChannelPtr &amp;tube, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdatetime.html">QDateTime</a> &amp;userActionTime, const <a class="el" href="a00106.html">Tp::ChannelRequestHints</a> &amp;hints)
<li>void <a class="el" href="a00384.html#aa6149284bb271c332a1ae974c86c4457">tubeClosed</a> (const Tp::AccountPtr &amp;account, const Tp::OutgoingStreamTubeChannelPtr &amp;tube, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;error, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;message)
<li>void <a class="el" href="a00384.html#a3a6fb43124b2047c3eca73097710ba64">newTcpConnection</a> (const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qhostaddress.html">QHostAddress</a> &amp;sourceAddress, quint16 sourcePort, const Tp::AccountPtr &amp;account, const Tp::ContactPtr &amp;contact, const Tp::OutgoingStreamTubeChannelPtr &amp;tube)
<li>void <a class="el" href="a00384.html#acc8f5fcc855b371430d3915754ad3a8b">tcpConnectionClosed</a> (const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qhostaddress.html">QHostAddress</a> &amp;sourceAddress, quint16 sourcePort, const Tp::AccountPtr &amp;account, const Tp::ContactPtr &amp;contact, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;error, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;message, const Tp::OutgoingStreamTubeChannelPtr &amp;tube)
</ul>
<h2><a name="pub-methods"></a>
Public Member Functions</h2>
<ul>
<li>virtual <a class="el" href="a00384.html#ac4ec3a4178996d1ea8305f25a25c9218">~StreamTubeServer</a> ()
<li>ClientRegistrarPtr <a class="el" href="a00384.html#ac0af546f4a3fa08ffb8207e450fdcf91">registrar</a> () const 
<li><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> <a class="el" href="a00384.html#a4f3ce4a3ebe9838e8911f7870560a34a">clientName</a> () const 
<li>bool <a class="el" href="a00384.html#a21dc72be595520a1982e8cdbc5b25441">isRegistered</a> () const 
<li>bool <a class="el" href="a00384.html#a26340af76407099a3b495daa615c7071">monitorsConnections</a> () const 
<li><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qpair.html">QPair</a>&lt; <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qhostaddress.html">QHostAddress</a>, quint16 &gt; <a class="el" href="a00384.html#abb2fb44ceeedfd62746f62dce30a35d3">exportedTcpSocketAddress</a> () const 
<li>QVariantMap <a class="el" href="a00384.html#aede3b7140c63b6ab77d0282a6cf90bb8">exportedParameters</a> () const 
<li>void <a class="el" href="a00384.html#ac0675a57b83d927f357c3005de8f8fc9">exportTcpSocket</a> (const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qhostaddress.html">QHostAddress</a> &amp;address, quint16 port, const QVariantMap &amp;parameters=QVariantMap())
<li>void <a class="el" href="a00384.html#a2ffd7f4775bcf196b8cf41c702692e45">exportTcpSocket</a> (const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qtcpserver.html">QTcpServer</a> *server, const QVariantMap &amp;parameters=QVariantMap())
<li>void <a class="el" href="a00384.html#a6e128b4f8b23eb78b8463a2898c21943">exportTcpSocket</a> (const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qhostaddress.html">QHostAddress</a> &amp;address, quint16 port, <a class="el" href="a00288.html">ParametersGenerator</a> *generator)
<li>void <a class="el" href="a00384.html#a5782864765424878c2fa632bd8760a56">exportTcpSocket</a> (const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qtcpserver.html">QTcpServer</a> *server, <a class="el" href="a00288.html">ParametersGenerator</a> *generator)
<li><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qlist.html">QList</a>&lt; <a class="el" href="a00394.html">Tube</a> &gt; <a class="el" href="a00384.html#a5e7f76884a85b7a3b97e4f0cceaf2c6a">tubes</a> () const 
<li><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qhash.html">QHash</a>&lt; <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qpair.html">QPair</a>&lt; <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qhostaddress.html">QHostAddress</a>, <br class="typebreak"/>
quint16 &gt;, <a class="el" href="a00338.html">RemoteContact</a> &gt; <a class="el" href="a00384.html#a6eae36057f2b458d0ee561a8d16cd25c">tcpConnections</a> () const 
</ul>
<h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2>
<ul>
<li>static StreamTubeServerPtr <a class="el" href="a00384.html#a942ccb0e1c3326fee2fb2034c78d39bf">create</a> (const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> &amp;p2pServices, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> &amp;roomServices=<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a>(), const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;clientName=<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a>(), bool monitorConnections=false, const AccountFactoryConstPtr &amp;accountFactory=AccountFactory::create(<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusconnection.html#sessionBus">QDBusConnection::sessionBus</a>()), const ConnectionFactoryConstPtr &amp;connectionFactory=ConnectionFactory::create(<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusconnection.html#sessionBus">QDBusConnection::sessionBus</a>()), const ChannelFactoryConstPtr &amp;channelFactory=ChannelFactory::create(<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusconnection.html#sessionBus">QDBusConnection::sessionBus</a>()), const ContactFactoryConstPtr &amp;contactFactory=ContactFactory::create())
<li>static StreamTubeServerPtr <a class="el" href="a00384.html#af29e1b553452032f8e5942c72c1bb1c9">create</a> (const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusconnection.html">QDBusConnection</a> &amp;bus, const AccountFactoryConstPtr &amp;accountFactory, const ConnectionFactoryConstPtr &amp;connectionFactory, const ChannelFactoryConstPtr &amp;channelFactory, const ContactFactoryConstPtr &amp;contactFactory, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> &amp;p2pServices, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> &amp;roomServices=<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a>(), const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;clientName=<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a>(), bool monitorConnections=false)
<li>static StreamTubeServerPtr <a class="el" href="a00384.html#a17ce8c6e4263ee55db9afba3fc6f3f5b">create</a> (const AccountManagerPtr &amp;accountManager, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> &amp;p2pServices, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> &amp;roomServices=<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a>(), const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;clientName=<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a>(), bool monitorConnections=false)
<li>static StreamTubeServerPtr <a class="el" href="a00384.html#af2425e6b5409b3720a89e62aa1fc617f">create</a> (const ClientRegistrarPtr &amp;registrar, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> &amp;p2pServices, const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> &amp;roomServices=<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a>(), const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;clientName=<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a>(), bool monitorConnections=false)
</ul>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="a00384.html" title="The StreamTubeServer class is a Handler implementation for outgoing Stream Tube channels, allowing an application to easily export a TCP network server over Telepathy Tubes without worrying about the channel dispatching details.">StreamTubeServer</a> class is a Handler implementation for outgoing Stream Tube channels, allowing an application to easily export a TCP network server over Telepathy Tubes without worrying about the channel dispatching details. </p>
<p>Telepathy Tubes is a technology for connecting arbitrary applications together through the IM network (and sometimes with direct peer-to-peer connections), such that issues like firewall/NAT traversal are automatically handled. Stream Tubes in particular offer properties similar to SOCK_STREAM sockets. The <a class="el" href="a00384.html" title="The StreamTubeServer class is a Handler implementation for outgoing Stream Tube channels, allowing an application to easily export a TCP network server over Telepathy Tubes without worrying about the channel dispatching details.">StreamTubeServer</a> class exports such a bytestream socket <b>server</b> over the tubes it <em>handles</em> as a Telepathy Handler Client; the <a class="el" href="a00383.html" title="The StreamTubeClient class is a Handler implementation for incoming Stream Tube channels, allowing an application to easily get notified about services they can connect to offered to them over Telepathy Tubes without worrying about the channel dispatching details.">StreamTubeClient</a> class is the counterpart, enabling TCP/UNIX socket clients to connect to services from such exported servers offered to them via tubes.</p>
<p>Both peer-to-peer (<code>TargetHandleType</code> == <a class="el" href="a00655.html#ga36fa367f622d8b98416393b3fe4c89d2a5c0c85266c24696c080d2a688ec8bfa3">HandleTypeContact</a>) and group (<code>TargetHandleType</code> == <a class="el" href="a00655.html#ga36fa367f622d8b98416393b3fe4c89d2ac4186e266a163cb4ced697e949b02cd3">HandleTypeRoom</a>) channels are supported, and it's possible to specify the tube services to handle for each separately. It is also possible to not advertise handling capability for ANY tube service; instead just using the <a class="el" href="a00384.html" title="The StreamTubeServer class is a Handler implementation for outgoing Stream Tube channels, allowing an application to easily export a TCP network server over Telepathy Tubes without worrying about the channel dispatching details.">StreamTubeServer</a> to handle tubes on an one-off basis by passing its corresponding Client service name as the <em>preferredHandler</em> when requesting tubes via the <a class="el" href="a00035.html#a859f4bad0a76afed783c133908c0fae5">Account::createStreamTube()</a> methods (or equivalent).</p>
<p>Connection monitoring allows associating incoming connections on the exported server socket with the corresponding remote contacts. This allows an application to show the details of and/or initiate further communication with the remote contacts, without considering the actual tube channels the connections are being made through at all (in particular, their <a class="el" href="a00077.html#a7769265d5da24e22e1b6a23cdb99c9ae">Channel::targetContact()</a> accessor for peer-to-peer and the <a class="el" href="a00285.html#ab98c4b3e65fa2cc70fe079e8ac72fb30">OutgoingStreamTubeChannel::connectionsForSourceAddresses()</a> accessor for group tubes).</p>
<p>Enabling connection monitoring adds a small overhead and latency to handling each incoming tube and signaling each new incoming connection over them, though, so use it only when needed. Additionally, some protocol backends or environments they're running in might not support the <a class="el" href="a00655.html#ga59816b3c275bf13857e694c6ecec5fc9a2c0ee1efb68ecddb8109490f3cd0f38d">SocketAccessControlPort</a> mechanism, in which case the source address won't be reported for connections through them. Even in this case, the remote contacts can be associated by accepting one incoming socket connection at a time, and waiting for the corresponding contact to be signaled (although its source address will be invalid, it's the only possibility given its the only accepted connection). However, it's not necessary to do this e.g. with the Gabble XMPP backend, because it fully supports the required mechanism.</p>
<p>A service activated Handler can be implemented using <a class="el" href="a00384.html" title="The StreamTubeServer class is a Handler implementation for outgoing Stream Tube channels, allowing an application to easily export a TCP network server over Telepathy Tubes without worrying about the channel dispatching details.">StreamTubeServer</a> by passing a predefined <em>clientName</em> manually to the chosen <a class="el" href="a00384.html#a942ccb0e1c3326fee2fb2034c78d39bf">create()</a> method, and installing Telepathy <code></code>.client and D-Bus <code></code>.service files declaring the implemented tube services as channel classes and a path to the executable. If this is not needed, the <em>clientName</em> can be omitted, in which case a random unique client name is generated and used instead.</p>
<p><a class="el" href="a00384.html" title="The StreamTubeServer class is a Handler implementation for outgoing Stream Tube channels, allowing an application to easily export a TCP network server over Telepathy Tubes without worrying about the channel dispatching details.">StreamTubeServer</a> shares <a class="el" href="a00035.html" title="The Account class represents a Telepathy account.">Account</a>, <a class="el" href="a00127.html" title="The Connection class represents a Telepathy connection.">Connection</a> and <a class="el" href="a00077.html" title="The Channel class represents a Telepathy channel.">Channel</a> proxies and <a class="el" href="a00175.html" title="The Contact class represents a Telepathy contact.">Contact</a> objects with the rest of the application as long as a reference to the <a class="el" href="a00042.html" title="The AccountManager class represents a Telepathy account manager.">AccountManager</a>, <a class="el" href="a00125.html" title="The ClientRegistrar class is responsible for registering Telepathy clients (Observer, Approver, Handler).">ClientRegistrar</a>, or the factories used elsewhere is passed to the <a class="el" href="a00384.html#a942ccb0e1c3326fee2fb2034c78d39bf">create()</a> method. A stand-alone tube service Handler can get away without passing these however, or just passing select factories to make the desired features prepared and subclasses employed for these objects for their own convenience.</p>
<p>Whichever method is used, the <a class="el" href="a00086.html" title="The ChannelFactory class is responsible for constructing Channel objects according to application-def...">ChannelFactory</a> (perhaps indirectly) given must construct <a class="el" href="a00285.html" title="The OutgoingStreamTubeChannel class represents an outgoing Telepathy channel of type StreamTube...">OutgoingStreamTubeChannel</a> instances or subclasses thereof for all channel classes corresponding to the tube services to handle. This is the default; overriding it without obeying these constraints using <a class="el" href="a00086.html#a052c5dfa9740bd9232d7624964e0c830">ChannelFactory::setSubclassForOutgoingStreamTubes()</a> or the related methods for room tubes prevents <a class="el" href="a00384.html" title="The StreamTubeServer class is a Handler implementation for outgoing Stream Tube channels, allowing an application to easily export a TCP network server over Telepathy Tubes without worrying about the channel dispatching details.">StreamTubeServer</a> from operating correctly.</p>
<dl class="todo"><dt><b><a class="el" href="a00688.html#_todo000012">Todo:</a></b></dt><dd><p class="startdd">Coin up a small Python script or alike to easily generate the .client and .service files. (fd.o #41614) </p>
<p class="enddd">Support exporting Unix sockets as well. (fd.o #41615) </p>
</dd></dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac4ec3a4178996d1ea8305f25a25c9218"></a><!-- doxytag: member="Tp::StreamTubeServer::~StreamTubeServer" ref="ac4ec3a4178996d1ea8305f25a25c9218" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tp::StreamTubeServer::~StreamTubeServer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Class destructor. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a942ccb0e1c3326fee2fb2034c78d39bf"></a><!-- doxytag: member="Tp::StreamTubeServer::create" ref="a942ccb0e1c3326fee2fb2034c78d39bf" args="(const QStringList &amp;p2pServices, const QStringList &amp;roomServices=QStringList(), const QString &amp;clientName=QString(), bool monitorConnections=false, const AccountFactoryConstPtr &amp;accountFactory=AccountFactory::create(QDBusConnection::sessionBus()), const ConnectionFactoryConstPtr &amp;connectionFactory=ConnectionFactory::create(QDBusConnection::sessionBus()), const ChannelFactoryConstPtr &amp;channelFactory=ChannelFactory::create(QDBusConnection::sessionBus()), const ContactFactoryConstPtr &amp;contactFactory=ContactFactory::create())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StreamTubeServerPtr Tp::StreamTubeServer::create </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> &amp;&#160;</td>
          <td class="paramname"><em>p2pServices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> &amp;&#160;</td>
          <td class="paramname"><em>roomServices</em> = <code><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>clientName</em> = <code><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>monitorConnections</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AccountFactoryConstPtr &amp;&#160;</td>
          <td class="paramname"><em>accountFactory</em> = <code>AccountFactory::create(<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusconnection.html#sessionBus">QDBusConnection::sessionBus</a>())</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConnectionFactoryConstPtr &amp;&#160;</td>
          <td class="paramname"><em>connectionFactory</em> = <code>ConnectionFactory::create(<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusconnection.html#sessionBus">QDBusConnection::sessionBus</a>())</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ChannelFactoryConstPtr &amp;&#160;</td>
          <td class="paramname"><em>channelFactory</em> = <code>ChannelFactory::create(<a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusconnection.html#sessionBus">QDBusConnection::sessionBus</a>())</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContactFactoryConstPtr &amp;&#160;</td>
          <td class="paramname"><em>contactFactory</em> = <code>ContactFactory::create()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a new <a class="el" href="a00384.html" title="The StreamTubeServer class is a Handler implementation for outgoing Stream Tube channels, allowing an application to easily export a TCP network server over Telepathy Tubes without worrying about the channel dispatching details.">StreamTubeServer</a>, which will register itself on the session bus using an internal <a class="el" href="a00125.html" title="The ClientRegistrar class is responsible for registering Telepathy clients (Observer, Approver, Handler).">ClientRegistrar</a> and use the given factories.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p2pServices</td><td>Names of the tube services to handle on peer-to-peer tube channels. </td></tr>
    <tr><td class="paramname">roomServices</td><td>Names of the tube services to handle on room/group tube channels. </td></tr>
    <tr><td class="paramname">clientName</td><td>The client name (without the <code>org.freedesktop.Telepathy.Client</code>. prefix). </td></tr>
    <tr><td class="paramname">monitorConnections</td><td>Whether to enable connection monitoring or not. </td></tr>
    <tr><td class="paramname">accountFactory</td><td>The account factory to use. </td></tr>
    <tr><td class="paramname">connectionFactory</td><td>The connection factory to use. </td></tr>
    <tr><td class="paramname">channelFactory</td><td>The channel factory to use. </td></tr>
    <tr><td class="paramname">contactFactory</td><td>The contact factory to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af29e1b553452032f8e5942c72c1bb1c9"></a><!-- doxytag: member="Tp::StreamTubeServer::create" ref="af29e1b553452032f8e5942c72c1bb1c9" args="(const QDBusConnection &amp;bus, const AccountFactoryConstPtr &amp;accountFactory, const ConnectionFactoryConstPtr &amp;connectionFactory, const ChannelFactoryConstPtr &amp;channelFactory, const ContactFactoryConstPtr &amp;contactFactory, const QStringList &amp;p2pServices, const QStringList &amp;roomServices=QStringList(), const QString &amp;clientName=QString(), bool monitorConnections=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StreamTubeServerPtr Tp::StreamTubeServer::create </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdbusconnection.html">QDBusConnection</a> &amp;&#160;</td>
          <td class="paramname"><em>bus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AccountFactoryConstPtr &amp;&#160;</td>
          <td class="paramname"><em>accountFactory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConnectionFactoryConstPtr &amp;&#160;</td>
          <td class="paramname"><em>connectionFactory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ChannelFactoryConstPtr &amp;&#160;</td>
          <td class="paramname"><em>channelFactory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContactFactoryConstPtr &amp;&#160;</td>
          <td class="paramname"><em>contactFactory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> &amp;&#160;</td>
          <td class="paramname"><em>p2pServices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> &amp;&#160;</td>
          <td class="paramname"><em>roomServices</em> = <code><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>clientName</em> = <code><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>monitorConnections</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a new <a class="el" href="a00384.html" title="The StreamTubeServer class is a Handler implementation for outgoing Stream Tube channels, allowing an application to easily export a TCP network server over Telepathy Tubes without worrying about the channel dispatching details.">StreamTubeServer</a>, which will register itself on the given <em>bus</em> using an internal <a class="el" href="a00125.html" title="The ClientRegistrar class is responsible for registering Telepathy clients (Observer, Approver, Handler).">ClientRegistrar</a> and use the given factories.</p>
<p>The factories must all be created for the given <em>bus</em>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bus</td><td><a class="el" href="a00127.html" title="The Connection class represents a Telepathy connection.">Connection</a> to the bus to register on. </td></tr>
    <tr><td class="paramname">accountFactory</td><td>The account factory to use. </td></tr>
    <tr><td class="paramname">connectionFactory</td><td>The connection factory to use. </td></tr>
    <tr><td class="paramname">channelFactory</td><td>The channel factory to use. </td></tr>
    <tr><td class="paramname">contactFactory</td><td>The contact factory to use. </td></tr>
    <tr><td class="paramname">p2pServices</td><td>Names of the tube services to handle on peer-to-peer tube channels. </td></tr>
    <tr><td class="paramname">roomServices</td><td>Names of the tube services to handle on room/group tube channels. </td></tr>
    <tr><td class="paramname">clientName</td><td>The client name (without the <code>org.freedesktop.Telepathy.Client</code>. prefix). </td></tr>
    <tr><td class="paramname">monitorConnections</td><td>Whether to enable connection monitoring or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a17ce8c6e4263ee55db9afba3fc6f3f5b"></a><!-- doxytag: member="Tp::StreamTubeServer::create" ref="a17ce8c6e4263ee55db9afba3fc6f3f5b" args="(const AccountManagerPtr &amp;accountManager, const QStringList &amp;p2pServices, const QStringList &amp;roomServices=QStringList(), const QString &amp;clientName=QString(), bool monitorConnections=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StreamTubeServerPtr Tp::StreamTubeServer::create </td>
          <td>(</td>
          <td class="paramtype">const AccountManagerPtr &amp;&#160;</td>
          <td class="paramname"><em>accountManager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> &amp;&#160;</td>
          <td class="paramname"><em>p2pServices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> &amp;&#160;</td>
          <td class="paramname"><em>roomServices</em> = <code><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>clientName</em> = <code><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>monitorConnections</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a new <a class="el" href="a00384.html" title="The StreamTubeServer class is a Handler implementation for outgoing Stream Tube channels, allowing an application to easily export a TCP network server over Telepathy Tubes without worrying about the channel dispatching details.">StreamTubeServer</a>, which will register itself on the bus of and share objects with the given <em>accountManager</em>, creating an internal <a class="el" href="a00125.html" title="The ClientRegistrar class is responsible for registering Telepathy clients (Observer, Approver, Handler).">ClientRegistrar</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">accountManager</td><td>A pointer to the account manager to link up with. </td></tr>
    <tr><td class="paramname">p2pServices</td><td>Names of the tube services to handle on peer-to-peer tube channels. </td></tr>
    <tr><td class="paramname">roomServices</td><td>Names of the tube services to handle on room/group tube channels. </td></tr>
    <tr><td class="paramname">clientName</td><td>The client name (without the <code>org.freedesktop.Telepathy.Client</code>. prefix). </td></tr>
    <tr><td class="paramname">monitorConnections</td><td>Whether to enable connection monitoring or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af2425e6b5409b3720a89e62aa1fc617f"></a><!-- doxytag: member="Tp::StreamTubeServer::create" ref="af2425e6b5409b3720a89e62aa1fc617f" args="(const ClientRegistrarPtr &amp;registrar, const QStringList &amp;p2pServices, const QStringList &amp;roomServices=QStringList(), const QString &amp;clientName=QString(), bool monitorConnections=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StreamTubeServerPtr Tp::StreamTubeServer::create </td>
          <td>(</td>
          <td class="paramtype">const ClientRegistrarPtr &amp;&#160;</td>
          <td class="paramname"><em>registrar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> &amp;&#160;</td>
          <td class="paramname"><em>p2pServices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a> &amp;&#160;</td>
          <td class="paramname"><em>roomServices</em> = <code><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstringlist.html">QStringList</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>clientName</em> = <code><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>monitorConnections</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a new <a class="el" href="a00384.html" title="The StreamTubeServer class is a Handler implementation for outgoing Stream Tube channels, allowing an application to easily export a TCP network server over Telepathy Tubes without worrying about the channel dispatching details.">StreamTubeServer</a>, which will register itself on the bus of and using the given client <em>registrar</em>, and share objects with it.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">registrar</td><td>The client registrar to use. </td></tr>
    <tr><td class="paramname">p2pServices</td><td>Names of the tube services to handle on peer-to-peer tube channels. </td></tr>
    <tr><td class="paramname">roomServices</td><td>Names of the tube services to handle on room/group tube channels. </td></tr>
    <tr><td class="paramname">clientName</td><td>The client name (without the <code>org.freedesktop.Telepathy.Client</code>. prefix). </td></tr>
    <tr><td class="paramname">monitorConnections</td><td>Whether to enable connection monitoring or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac0af546f4a3fa08ffb8207e450fdcf91"></a><!-- doxytag: member="Tp::StreamTubeServer::registrar" ref="ac0af546f4a3fa08ffb8207e450fdcf91" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ClientRegistrarPtr Tp::StreamTubeServer::registrar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the client registrar used by the server to register itself as a Handler client.</p>
<p>This is the registrar originally passed to <a class="el" href="a00384.html#af2425e6b5409b3720a89e62aa1fc617f">create(const ClientRegistrarPtr &amp;, const QStringList &amp;, const QStringList &amp;, const QString &amp;, bool)</a> if that was used, and an internally constructed one otherwise. In any case, it can be used to e.g. register further clients like any other <a class="el" href="a00125.html" title="The ClientRegistrar class is responsible for registering Telepathy clients (Observer, Approver, Handler).">ClientRegistrar</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the registrar. </dd></dl>

</div>
</div>
<a class="anchor" id="a4f3ce4a3ebe9838e8911f7870560a34a"></a><!-- doxytag: member="Tp::StreamTubeServer::clientName" ref="a4f3ce4a3ebe9838e8911f7870560a34a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> Tp::StreamTubeServer::clientName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the Telepathy Client name of the server.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The name, without the <code>org.freedesktop.Telepathy.Client</code>. prefix of the full D-Bus service name. </dd></dl>

</div>
</div>
<a class="anchor" id="a21dc72be595520a1982e8cdbc5b25441"></a><!-- doxytag: member="Tp::StreamTubeServer::isRegistered" ref="a21dc72be595520a1982e8cdbc5b25441" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Tp::StreamTubeServer::isRegistered </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return whether the server has been successfully registered or not.</p>
<p>Registration is attempted, at the latest, when a socket is first exported using <a class="el" href="a00384.html#ac0675a57b83d927f357c3005de8f8fc9">exportTcpSocket()</a>. It can fail e.g. because the connection to the bus has failed, or a predefined <em>clientName</em> has been passed to <a class="el" href="a00384.html#a942ccb0e1c3326fee2fb2034c78d39bf">create()</a>, and a Client with the same name is already registered. Typically, failure registering would be a fatal error for a stand-alone tube handler, but only a warning event for an application serving other purposes. In any case, a high-quality user of the API will check the return value of this accessor after exporting their socket.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the server has been successfully registered, <code>false</code> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a26340af76407099a3b495daa615c7071"></a><!-- doxytag: member="Tp::StreamTubeServer::monitorsConnections" ref="a26340af76407099a3b495daa615c7071" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Tp::StreamTubeServer::monitorsConnections </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return whether connection monitoring is enabled on this server.</p>
<p>For technical reasons, connection monitoring can't be enabled when the server is already running, so there is no corresponding setter method. It has to be enabled by passing <code>true</code> as the <em>monitorConnections</em> parameter to the <a class="el" href="a00384.html#a942ccb0e1c3326fee2fb2034c78d39bf">create()</a> method.</p>
<p>If connection monitoring isn't enabled, <a class="el" href="a00384.html#a3a6fb43124b2047c3eca73097710ba64">newTcpConnection()</a> and <a class="el" href="a00384.html#acc8f5fcc855b371430d3915754ad3a8b">tcpConnectionClosed()</a> won't be emitted and <a class="el" href="a00384.html#a6eae36057f2b458d0ee561a8d16cd25c">tcpConnections()</a> won't be populated.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if monitoring is enabled, <code>false</code> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="abb2fb44ceeedfd62746f62dce30a35d3"></a><!-- doxytag: member="Tp::StreamTubeServer::exportedTcpSocketAddress" ref="abb2fb44ceeedfd62746f62dce30a35d3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qpair.html">QPair</a>&lt; <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qhostaddress.html">QHostAddress</a>, quint16 &gt; Tp::StreamTubeServer::exportedTcpSocketAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the host address and port of the currently exported TCP socket, if any.</p>
<p>QHostAddress::Null is reported as the address and 0 as the port if no TCP socket has yet been successfully exported.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The host address and port values in a pair structure. </dd></dl>

</div>
</div>
<a class="anchor" id="aede3b7140c63b6ab77d0282a6cf90bb8"></a><!-- doxytag: member="Tp::StreamTubeServer::exportedParameters" ref="aede3b7140c63b6ab77d0282a6cf90bb8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QVariantMap Tp::StreamTubeServer::exportedParameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the fixed parameters, if any, which are sent along when offering the exported socket on all handled tubes.</p>
<p>To prevent accidentally leaving the current parameters to be sent when offering a different socket, or vice versa, the parameters can only be set together with the socket using <a class="el" href="a00384.html#ac0675a57b83d927f357c3005de8f8fc9">exportTcpSocket()</a>. Parameters often contain sensitive information such as session identifiers or authentication credentials, which could then be used to maliciously access the service listening on the other socket.</p>
<p>If a custom dynamic <a class="el" href="a00288.html" title="The StreamTubeServer::ParametersGenerator abstract interface allows sending a different set of parame...">ParametersGenerator</a> was passed to <a class="el" href="a00384.html#ac0675a57b83d927f357c3005de8f8fc9">exportTcpSocket()</a> instead of a set of fixed parameters, an empty set of parameters is returned.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The parameters in a string-variant map. </dd></dl>

</div>
</div>
<a class="anchor" id="ac0675a57b83d927f357c3005de8f8fc9"></a><!-- doxytag: member="Tp::StreamTubeServer::exportTcpSocket" ref="ac0675a57b83d927f357c3005de8f8fc9" args="(const QHostAddress &amp;address, quint16 port, const QVariantMap &amp;parameters=QVariantMap())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tp::StreamTubeServer::exportTcpSocket </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qhostaddress.html">QHostAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">quint16&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVariantMap &amp;&#160;</td>
          <td class="paramname"><em>parameters</em> = <code>QVariantMap()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the server to offer the socket listening at the given (<em>address</em>, <em>port</em>) combination as the local endpoint of tubes handled in the future.</p>
<p>A fixed set of protocol bootstrapping <em>parameters</em> can optionally be set to be sent along with all tube offers until the next call to <a class="el" href="a00384.html#ac0675a57b83d927f357c3005de8f8fc9">exportTcpSocket()</a>. See the <a class="el" href="a00288.html" title="The StreamTubeServer::ParametersGenerator abstract interface allows sending a different set of parame...">ParametersGenerator</a> documentation for an in-depth description of the parameter transfer mechanism, and a more flexible way to vary the parameters between each handled tube.</p>
<p>The handler is registered on the bus at the latest when this method or another <a class="el" href="a00384.html#ac0675a57b83d927f357c3005de8f8fc9">exportTcpSocket()</a> overload is called for the first time, so one should check the return value of <a class="el" href="a00384.html#a21dc72be595520a1982e8cdbc5b25441">isRegistered()</a> at that point to verify that was successful.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The listen address of the socket. </td></tr>
    <tr><td class="paramname">port</td><td>The port of the socket. </td></tr>
    <tr><td class="paramname">parameters</td><td>The bootstrapping parameters in a string-value map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2ffd7f4775bcf196b8cf41c702692e45"></a><!-- doxytag: member="Tp::StreamTubeServer::exportTcpSocket" ref="a2ffd7f4775bcf196b8cf41c702692e45" args="(const QTcpServer *server, const QVariantMap &amp;parameters=QVariantMap())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tp::StreamTubeServer::exportTcpSocket </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qtcpserver.html">QTcpServer</a> *&#160;</td>
          <td class="paramname"><em>server</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVariantMap &amp;&#160;</td>
          <td class="paramname"><em>parameters</em> = <code>QVariantMap()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the <a class="el" href="a00384.html" title="The StreamTubeServer class is a Handler implementation for outgoing Stream Tube channels, allowing an application to easily export a TCP network server over Telepathy Tubes without worrying about the channel dispatching details.">StreamTubeServer</a> to offer the already listening TCP <em>server</em> as the local endpoint of tubes handled in the future.</p>
<p>This is just a convenience wrapper around <a class="el" href="a00384.html#ac0675a57b83d927f357c3005de8f8fc9">exportTcpSocket(const QHostAddress &amp;, quint16, const QVariantMap &amp;)</a> to be used when the TCP server code is implemented using the QtNetwork facilities.</p>
<p>A fixed set of protocol bootstrapping <em>parameters</em> can optionally be set to be sent along with all tube offers until the next call to <a class="el" href="a00384.html#ac0675a57b83d927f357c3005de8f8fc9">exportTcpSocket()</a>. See the <a class="el" href="a00288.html" title="The StreamTubeServer::ParametersGenerator abstract interface allows sending a different set of parame...">ParametersGenerator</a> documentation for an in-depth description of the parameter transfer mechanism, and a more flexible way to vary the parameters between each handled tube.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">server</td><td>A pointer to the TCP server. </td></tr>
    <tr><td class="paramname">parameters</td><td>The bootstrapping parameters in a string-value map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6e128b4f8b23eb78b8463a2898c21943"></a><!-- doxytag: member="Tp::StreamTubeServer::exportTcpSocket" ref="a6e128b4f8b23eb78b8463a2898c21943" args="(const QHostAddress &amp;address, quint16 port, ParametersGenerator *generator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tp::StreamTubeServer::exportTcpSocket </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qhostaddress.html">QHostAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">quint16&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00288.html">ParametersGenerator</a> *&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the server to offer the socket listening at the given <em>address</em> - <em>port</em> combination as the local endpoint of tubes handled in the future, sending the parameters from the given <em>generator</em> along with the offers.</p>
<p>The handler is registered on the bus at the latest when this method or another <a class="el" href="a00384.html#ac0675a57b83d927f357c3005de8f8fc9">exportTcpSocket()</a> overload is called for the first time, so one should check the return value of <a class="el" href="a00384.html#a21dc72be595520a1982e8cdbc5b25441">isRegistered()</a> at that point to verify that was successful.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The listen address of the socket. </td></tr>
    <tr><td class="paramname">port</td><td>The port of the socket. </td></tr>
    <tr><td class="paramname">generator</td><td>A pointer to the bootstrapping parameters generator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5782864765424878c2fa632bd8760a56"></a><!-- doxytag: member="Tp::StreamTubeServer::exportTcpSocket" ref="a5782864765424878c2fa632bd8760a56" args="(const QTcpServer *server, ParametersGenerator *generator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tp::StreamTubeServer::exportTcpSocket </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qtcpserver.html">QTcpServer</a> *&#160;</td>
          <td class="paramname"><em>server</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00288.html">ParametersGenerator</a> *&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the server to offer the already listening TCP <em>server</em> as the local endpoint of tubes handled in the future, sending the parameters from the given <em>generator</em> along with the offers.</p>
<p>This is just a convenience wrapper around <a class="el" href="a00384.html#a6e128b4f8b23eb78b8463a2898c21943">exportTcpSocket(const QHostAddress &amp;, quint16, ParametersGenerator *)</a> to be used when the TCP server code is implemented using the QtNetwork facilities.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">server</td><td>A pointer to the TCP server. </td></tr>
    <tr><td class="paramname">generator</td><td>A pointer to the bootstrapping parameters generator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5e7f76884a85b7a3b97e4f0cceaf2c6a"></a><!-- doxytag: member="Tp::StreamTubeServer::tubes" ref="a5e7f76884a85b7a3b97e4f0cceaf2c6a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qlist.html">QList</a>&lt; <a class="el" href="a00394.html">StreamTubeServer::Tube</a> &gt; Tp::StreamTubeServer::tubes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the tubes currently handled by the server.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A list of <a class="el" href="a00394.html" title="The StreamTubeServer::Tube class represents a tube being handled by the server.">Tube</a> structures containing pointers to the account and tube channel for each tube. </dd></dl>

</div>
</div>
<a class="anchor" id="a6eae36057f2b458d0ee561a8d16cd25c"></a><!-- doxytag: member="Tp::StreamTubeServer::tcpConnections" ref="a6eae36057f2b458d0ee561a8d16cd25c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qhash.html">QHash</a>&lt; <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qpair.html">QPair</a>&lt; <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qhostaddress.html">QHostAddress</a>, quint16 &gt;, <a class="el" href="a00338.html">StreamTubeServer::RemoteContact</a> &gt; Tp::StreamTubeServer::tcpConnections </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the ongoing TCP connections over tubes handled by this server.</p>
<p>The returned mapping has the connection source addresses as keys and the contacts along with the accounts which can be used to reach them as values. Connections through protocol backends which don't support SocketAccessControlPort will be included as the potentially many values for the null source address key, the pair (<code>QHostAddress::Null</code>, 0).</p>
<p>This is effectively a state recovery accessor corresponding to the change notification signals <a class="el" href="a00384.html#a3a6fb43124b2047c3eca73097710ba64">newTcpConnection()</a> and <a class="el" href="a00384.html#acc8f5fcc855b371430d3915754ad3a8b">tcpConnectionClosed()</a>.</p>
<p>The mapping is only populated if connection monitoring was requested when creating the server (so <a class="el" href="a00384.html#a26340af76407099a3b495daa615c7071">monitorsConnections()</a> returns <code>true</code>).</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The connections in a mapping with pairs of their source host addresses and ports as keys and structures containing pointers to the account and remote contacts they're from as values. </dd></dl>

</div>
</div>
<a class="anchor" id="a79863540c66e7370bfc31b76cefbc9e4"></a><!-- doxytag: member="Tp::StreamTubeServer::tubeRequested" ref="a79863540c66e7370bfc31b76cefbc9e4" args="(const Tp::AccountPtr &amp;account, const Tp::OutgoingStreamTubeChannelPtr &amp;tube, const QDateTime &amp;userActionTime, const Tp::ChannelRequestHints &amp;hints)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tp::StreamTubeServer::tubeRequested </td>
          <td>(</td>
          <td class="paramtype">const Tp::AccountPtr &amp;&#160;</td>
          <td class="paramname"><em>account</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tp::OutgoingStreamTubeChannelPtr &amp;&#160;</td>
          <td class="paramname"><em>tube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qdatetime.html">QDateTime</a> &amp;&#160;</td>
          <td class="paramname"><em>userActionTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00106.html">Tp::ChannelRequestHints</a> &amp;&#160;</td>
          <td class="paramname"><em>hints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Emitted when a tube has been requested for one of our services, and we've began handling it.</p>
<p>This is emitted before invoking the <a class="el" href="a00288.html" title="The StreamTubeServer::ParametersGenerator abstract interface allows sending a different set of parame...">ParametersGenerator</a>, if any, for the tube.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">account</td><td>A pointer to the account from which the tube was requested from. </td></tr>
    <tr><td class="paramname">tube</td><td>A pointer to the actual tube channel. </td></tr>
    <tr><td class="paramname">userActionTime</td><td>The time the request occurred at, if it was an user action. Should be used for focus stealing prevention. </td></tr>
    <tr><td class="paramname">hints</td><td>The hints passed to the request, if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa6149284bb271c332a1ae974c86c4457"></a><!-- doxytag: member="Tp::StreamTubeServer::tubeClosed" ref="aa6149284bb271c332a1ae974c86c4457" args="(const Tp::AccountPtr &amp;account, const Tp::OutgoingStreamTubeChannelPtr &amp;tube, const QString &amp;error, const QString &amp;message)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tp::StreamTubeServer::tubeClosed </td>
          <td>(</td>
          <td class="paramtype">const Tp::AccountPtr &amp;&#160;</td>
          <td class="paramname"><em>account</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tp::OutgoingStreamTubeChannelPtr &amp;&#160;</td>
          <td class="paramname"><em>tube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Emitted when a tube we've been handling (previously announced with <a class="el" href="a00384.html#a79863540c66e7370bfc31b76cefbc9e4">tubeRequested()</a>) has encountered an error or has otherwise been closed from further communication.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">account</td><td>A pointer to the account from which the tube was requested from. </td></tr>
    <tr><td class="paramname">tube</td><td>A pointer to the actual tube channel. </td></tr>
    <tr><td class="paramname">error</td><td>The D-Bus error name corresponding to the reason for the closure. </td></tr>
    <tr><td class="paramname">message</td><td>A freeform debug message associated with the error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3a6fb43124b2047c3eca73097710ba64"></a><!-- doxytag: member="Tp::StreamTubeServer::newTcpConnection" ref="a3a6fb43124b2047c3eca73097710ba64" args="(const QHostAddress &amp;sourceAddress, quint16 sourcePort, const Tp::AccountPtr &amp;account, const Tp::ContactPtr &amp;contact, const Tp::OutgoingStreamTubeChannelPtr &amp;tube)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tp::StreamTubeServer::newTcpConnection </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qhostaddress.html">QHostAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">quint16&#160;</td>
          <td class="paramname"><em>sourcePort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tp::AccountPtr &amp;&#160;</td>
          <td class="paramname"><em>account</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tp::ContactPtr &amp;&#160;</td>
          <td class="paramname"><em>contact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tp::OutgoingStreamTubeChannelPtr &amp;&#160;</td>
          <td class="paramname"><em>tube</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Emitted when we have picked up a new TCP connection to the (current or previous) exported server socket. This can be used to associate connections the protocol backend relays to the exported socket with the remote contact who originally initiated them in the other end of the tube.</p>
<p>This is only emitted if connection monitoring was enabled when creating the <a class="el" href="a00384.html" title="The StreamTubeServer class is a Handler implementation for outgoing Stream Tube channels, allowing an application to easily export a TCP network server over Telepathy Tubes without worrying about the channel dispatching details.">StreamTubeServer</a>. Additionally, if the protocol backend the connection is from doesn't support the <a class="el" href="a00655.html#ga59816b3c275bf13857e694c6ecec5fc9a2c0ee1efb68ecddb8109490f3cd0f38d">SocketAccessControlPort</a> mechanism, the source address and port will always be invalid.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceAddress</td><td>The source address of the connection, or QHostAddress::Null if it can't be resolved. </td></tr>
    <tr><td class="paramname">sourcePort</td><td>The source port of the connection, or 0 if it can't be resolved. </td></tr>
    <tr><td class="paramname">account</td><td>A pointer to the account through which the remote contact can be reached. </td></tr>
    <tr><td class="paramname">contact</td><td>A pointer to the remote contact object. </td></tr>
    <tr><td class="paramname">tube</td><td>A pointer to the tube channel through which the connection has been made. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acc8f5fcc855b371430d3915754ad3a8b"></a><!-- doxytag: member="Tp::StreamTubeServer::tcpConnectionClosed" ref="acc8f5fcc855b371430d3915754ad3a8b" args="(const QHostAddress &amp;sourceAddress, quint16 sourcePort, const Tp::AccountPtr &amp;account, const Tp::ContactPtr &amp;contact, const QString &amp;error, const QString &amp;message, const Tp::OutgoingStreamTubeChannelPtr &amp;tube)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tp::StreamTubeServer::tcpConnectionClosed </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qhostaddress.html">QHostAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">quint16&#160;</td>
          <td class="paramname"><em>sourcePort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tp::AccountPtr &amp;&#160;</td>
          <td class="paramname"><em>account</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tp::ContactPtr &amp;&#160;</td>
          <td class="paramname"><em>contact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tags:/you/forgot/to/run/installdox" href="/you/forgot/to/run/installdox/qstring.html">QString</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tp::OutgoingStreamTubeChannelPtr &amp;&#160;</td>
          <td class="paramname"><em>tube</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Emitted when a TCP connection (previously announced with <a class="el" href="a00384.html#a3a6fb43124b2047c3eca73097710ba64">newTcpConnection()</a>) through one of our handled tubes has been closed due to an error or by a graceful disconnect (in which case the error is <a class="el" href="a00683.html#ga3c33f19bce6abd20e2f5e44d2e86bf4a">TP_QT4_ERROR_DISCONNECTED</a>).</p>
<p>This is only emitted if connection monitoring was enabled when creating the <a class="el" href="a00384.html" title="The StreamTubeServer class is a Handler implementation for outgoing Stream Tube channels, allowing an application to easily export a TCP network server over Telepathy Tubes without worrying about the channel dispatching details.">StreamTubeServer</a>. Additionally, if the protocol backend the connection is from doesn't support the <a class="el" href="a00655.html#ga59816b3c275bf13857e694c6ecec5fc9a2c0ee1efb68ecddb8109490f3cd0f38d">SocketAccessControlPort</a> mechanism, the source address and port will always be invalid.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceAddress</td><td>The source address of the connection, or QHostAddress::Null if it couldn't be resolved. </td></tr>
    <tr><td class="paramname">sourcePort</td><td>The source port of the connection, or 0 if it couldn't be resolved. </td></tr>
    <tr><td class="paramname">account</td><td>A pointer to the account through which the remote contact can be reached. </td></tr>
    <tr><td class="paramname">contact</td><td>A pointer to the remote contact object. </td></tr>
    <tr><td class="paramname">error</td><td>The D-Bus error name corresponding to the reason for the closure. </td></tr>
    <tr><td class="paramname">message</td><td>A freeform debug message associated with the error. </td></tr>
    <tr><td class="paramname">tube</td><td>A pointer to the tube channel through which the connection has been made. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td width="30%">Copyright &copy; 2008-2011 Collabora Ltd. and Nokia Corporation</td>
<td width="30%" align="right"><div align="right">Telepathy-Qt4 0.8.0</div></td>
</tr></table></div></address>
</body>
</html>
